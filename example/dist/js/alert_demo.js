/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\nmodule.exports = {\"content\":\"content\",\"btn\":\"btn\"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9hbGVydF9kZW1vL3N0eWxlLnNjc3M/ODFkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQiIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wiY29udGVudFwiOlwiY29udGVudFwiLFwiYnRuXCI6XCJidG5cIn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9hbGVydF9kZW1vL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(8);\n\n__webpack_require__(0);\n\nvar _index = __webpack_require__(6);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar $body = $(\"body\");\n// alert\n$body.on('click', '.J-alert', function () {\n  (0, _index2.default)({\n    type: \"alert\",\n    title: \"这是确认信息\",\n    okText: \"确认\",\n    callback: function callback(result) {\n      console.log('\\u4F60\\u70B9\\u51FB\\u4E86' + result);\n    }\n  });\n}).on('click', '.J-confirm', function () {\n  (0, _index2.default)('提醒信息1', 'confirm');\n}).on('click', '.J-confirm-two', function () {\n  (0, _index2.default)({\n    type: \"confirm\",\n    title: ['这是提示信息1', '这是提示信息2'],\n    okText: \"确认\",\n    cancelText: \"取消\",\n    callback: function callback(result) {\n      console.log('\\u4F60\\u70B9\\u51FB\\u4E86' + result);\n    }\n  });\n}).on(\"click\", \".J-confirm-msg\", function () {\n  (0, _index2.default)({\n    type: \"confirm\",\n    title: \"这是标题\",\n    msg: \"这里是内容描述，这里是内容描述，这里是内容描述，这里是内容描述\",\n    okText: \"我知道了\",\n    callback: function callback(result) {\n      console.log('\\u4F60\\u70B9\\u51FB\\u4E86' + result);\n    }\n  });\n}).on(\"click\", \".J-alert-html\", function () {\n  (0, _index2.default)({\n    type: \"confirm\",\n    title: \"输入html\",\n    html: '<input type=\"text\" placeholder=\"这里是提示文案\">',\n    okText: \"我知道了\",\n    cancelText: \"我不知道\",\n    callback: function callback(result) {\n      console.log('\\u4F60\\u70B9\\u51FB\\u4E86' + result);\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9hbGVydF9kZW1vL2luZGV4LmpzPzU5MTYiXSwibmFtZXMiOlsiJGJvZHkiLCIkIiwib24iLCJ0eXBlIiwidGl0bGUiLCJva1RleHQiLCJjYWxsYmFjayIsInJlc3VsdCIsImNvbnNvbGUiLCJsb2ciLCJjYW5jZWxUZXh0IiwibXNnIiwiaHRtbCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFDQTs7QUFHQTs7Ozs7O0FBRUEsSUFBSUEsUUFBUUMsRUFBRSxNQUFGLENBQVo7QUFDQTtBQUNBRCxNQUNLRSxFQURMLENBQ1EsT0FEUixFQUNpQixVQURqQixFQUM2QixZQUFZO0FBQ25DLHVCQUFZO0FBQ1ZDLFVBQU0sT0FESTtBQUVWQyxXQUFPLFFBRkc7QUFHVkMsWUFBUSxJQUhFO0FBSVZDLGNBQVUsa0JBQUNDLE1BQUQsRUFBWTtBQUNwQkMsY0FBUUMsR0FBUiw4QkFBbUJGLE1BQW5CO0FBQ0Q7QUFOUyxHQUFaO0FBUUQsQ0FWTCxFQVdLTCxFQVhMLENBV1EsT0FYUixFQVdpQixZQVhqQixFQVcrQixZQUFZO0FBQ3JDLHVCQUFZLE9BQVosRUFBcUIsU0FBckI7QUFDRCxDQWJMLEVBY0tBLEVBZEwsQ0FjUSxPQWRSLEVBY2lCLGdCQWRqQixFQWNtQyxZQUFZO0FBQ3pDLHVCQUFZO0FBQ1ZDLFVBQU0sU0FESTtBQUVWQyxXQUFPLENBQUMsU0FBRCxFQUFZLFNBQVosQ0FGRztBQUdWQyxZQUFRLElBSEU7QUFJVkssZ0JBQVksSUFKRjtBQUtWSixjQUFVLGtCQUFDQyxNQUFELEVBQVk7QUFDcEJDLGNBQVFDLEdBQVIsOEJBQW1CRixNQUFuQjtBQUNEO0FBUFMsR0FBWjtBQVNELENBeEJMLEVBeUJLTCxFQXpCTCxDQXlCUSxPQXpCUixFQXlCaUIsZ0JBekJqQixFQXlCbUMsWUFBTTtBQUNuQyx1QkFBWTtBQUNWQyxVQUFNLFNBREk7QUFFVkMsV0FBTyxNQUZHO0FBR1ZPLFNBQUssaUNBSEs7QUFJVk4sWUFBUSxNQUpFO0FBS1ZDLGNBQVUsa0JBQUNDLE1BQUQsRUFBWTtBQUNwQkMsY0FBUUMsR0FBUiw4QkFBbUJGLE1BQW5CO0FBQ0Q7QUFQUyxHQUFaO0FBU0QsQ0FuQ0wsRUFvQ0tMLEVBcENMLENBb0NRLE9BcENSLEVBb0NpQixlQXBDakIsRUFvQ2tDLFlBQU07QUFDbEMsdUJBQVk7QUFDVkMsVUFBTSxTQURJO0FBRVZDLFdBQU8sUUFGRztBQUdWUSxVQUFNLDJDQUhJO0FBSVZQLFlBQVEsTUFKRTtBQUtWSyxnQkFBWSxNQUxGO0FBTVZKLGNBQVUsa0JBQUNDLE1BQUQsRUFBWTtBQUNwQkMsY0FBUUMsR0FBUiw4QkFBbUJGLE1BQW5CO0FBQ0Q7QUFSUyxHQUFaO0FBVUQsQ0EvQ0wiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9yZXNldC5zY3NzJztcbmltcG9ydCAnLi9zdHlsZS5zY3NzJztcblxuXG5pbXBvcnQgY3VzdG9tQWxlcnQgZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9hbGVydC9pbmRleCc7XG5cbmxldCAkYm9keSA9ICQoXCJib2R5XCIpO1xuLy8gYWxlcnRcbiRib2R5XG4gICAgLm9uKCdjbGljaycsICcuSi1hbGVydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1c3RvbUFsZXJ0KHtcbiAgICAgICAgdHlwZTogXCJhbGVydFwiLFxuICAgICAgICB0aXRsZTogXCLov5nmmK/noa7orqTkv6Hmga9cIixcbiAgICAgICAgb2tUZXh0OiBcIuehruiupFwiLFxuICAgICAgICBjYWxsYmFjazogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDkvaDngrnlh7vkuoYke3Jlc3VsdH1gKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIC5vbignY2xpY2snLCAnLkotY29uZmlybScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1c3RvbUFsZXJ0KCfmj5DphpLkv6Hmga8xJywgJ2NvbmZpcm0nKTtcbiAgICB9KVxuICAgIC5vbignY2xpY2snLCAnLkotY29uZmlybS10d28nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXN0b21BbGVydCh7XG4gICAgICAgIHR5cGU6IFwiY29uZmlybVwiLFxuICAgICAgICB0aXRsZTogWyfov5nmmK/mj5DnpLrkv6Hmga8xJywgJ+i/meaYr+aPkOekuuS/oeaBrzInXSxcbiAgICAgICAgb2tUZXh0OiBcIuehruiupFwiLFxuICAgICAgICBjYW5jZWxUZXh0OiBcIuWPlua2iFwiLFxuICAgICAgICBjYWxsYmFjazogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDkvaDngrnlh7vkuoYke3Jlc3VsdH1gKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIC5vbihcImNsaWNrXCIsIFwiLkotY29uZmlybS1tc2dcIiwgKCkgPT4ge1xuICAgICAgY3VzdG9tQWxlcnQoe1xuICAgICAgICB0eXBlOiBcImNvbmZpcm1cIixcbiAgICAgICAgdGl0bGU6IFwi6L+Z5piv5qCH6aKYXCIsXG4gICAgICAgIG1zZzogXCLov5nph4zmmK/lhoXlrrnmj4/ov7DvvIzov5nph4zmmK/lhoXlrrnmj4/ov7DvvIzov5nph4zmmK/lhoXlrrnmj4/ov7DvvIzov5nph4zmmK/lhoXlrrnmj4/ov7BcIixcbiAgICAgICAgb2tUZXh0OiBcIuaIkeefpemBk+S6hlwiLFxuICAgICAgICBjYWxsYmFjazogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDkvaDngrnlh7vkuoYke3Jlc3VsdH1gKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgLm9uKFwiY2xpY2tcIiwgXCIuSi1hbGVydC1odG1sXCIsICgpID0+IHtcbiAgICAgIGN1c3RvbUFsZXJ0KHtcbiAgICAgICAgdHlwZTogXCJjb25maXJtXCIsXG4gICAgICAgIHRpdGxlOiBcIui+k+WFpWh0bWxcIixcbiAgICAgICAgaHRtbDogJzxpbnB1dCB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwi6L+Z6YeM5piv5o+Q56S65paH5qGIXCI+JyxcbiAgICAgICAgb2tUZXh0OiBcIuaIkeefpemBk+S6hlwiLFxuICAgICAgICBjYW5jZWxUZXh0OiBcIuaIkeS4jeefpemBk1wiLFxuICAgICAgICBjYWxsYmFjazogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDkvaDngrnlh7vkuoYke3Jlc3VsdH1gKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFnZXMvYWxlcnRfZGVtby9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {\n    var a = factory();\n    for (var i in a) {\n      ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' ? exports : root)[i] = a[i];\n    }\n  }\n})(undefined, function () {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/function __webpack_require__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) {\n          /******/return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/var module = installedModules[moduleId] = {\n          /******/i: moduleId,\n          /******/l: false,\n          /******/exports: {}\n          /******/ };\n        /******/\n        /******/ // Execute the module function\n        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/module.l = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/__webpack_require__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/__webpack_require__.c = installedModules;\n      /******/\n      /******/ // identity function for calling harmony imports with the correct context\n      /******/__webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n      /******/ // define getter function for harmony exports\n      /******/__webpack_require__.d = function (exports, name, getter) {\n        /******/if (!__webpack_require__.o(exports, name)) {\n          /******/Object.defineProperty(exports, name, {\n            /******/configurable: false,\n            /******/enumerable: true,\n            /******/get: getter\n            /******/ });\n          /******/\n        }\n        /******/\n      };\n      /******/\n      /******/ // getDefaultExport function for compatibility with non-harmony modules\n      /******/__webpack_require__.n = function (module) {\n        /******/var getter = module && module.__esModule ?\n        /******/function getDefault() {\n          return module['default'];\n        } :\n        /******/function getModuleExports() {\n          return module;\n        };\n        /******/__webpack_require__.d(getter, 'a', getter);\n        /******/return getter;\n        /******/\n      };\n      /******/\n      /******/ // Object.prototype.hasOwnProperty.call\n      /******/__webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n      /******/ // __webpack_public_path__\n      /******/__webpack_require__.p = \"\";\n      /******/\n      /******/ // Load entry module and return exports\n      /******/return __webpack_require__(__webpack_require__.s = 11);\n      /******/\n    }(\n    /************************************************************************/\n    /******/[\n    /* 0 */\n    /***/function (module, exports, __webpack_require__) {\n\n      /**!\n      \n       @license\n       handlebars v4.0.11\n      \n      Copyright (C) 2011-2017 by Yehuda Katz\n      \n      Permission is hereby granted, free of charge, to any person obtaining a copy\n      of this software and associated documentation files (the \"Software\"), to deal\n      in the Software without restriction, including without limitation the rights\n      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n      copies of the Software, and to permit persons to whom the Software is\n      furnished to do so, subject to the following conditions:\n      \n      The above copyright notice and this permission notice shall be included in\n      all copies or substantial portions of the Software.\n      \n      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n      THE SOFTWARE.\n      \n      */\n      (function webpackUniversalModuleDefinition(root, factory) {\n        if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports[\"Handlebars\"] = factory();else root[\"Handlebars\"] = factory();\n      })(this, function () {\n        return (/******/function (modules) {\n            // webpackBootstrap\n            /******/ // The module cache\n            /******/var installedModules = {};\n\n            /******/ // The require function\n            /******/function __webpack_require__(moduleId) {\n\n              /******/ // Check if module is in cache\n              /******/if (installedModules[moduleId])\n                /******/return installedModules[moduleId].exports;\n\n              /******/ // Create a new module (and put it into the cache)\n              /******/var module = installedModules[moduleId] = {\n                /******/exports: {},\n                /******/id: moduleId,\n                /******/loaded: false\n                /******/ };\n\n              /******/ // Execute the module function\n              /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n              /******/ // Flag the module as loaded\n              /******/module.loaded = true;\n\n              /******/ // Return the exports of the module\n              /******/return module.exports;\n              /******/\n            }\n\n            /******/ // expose the modules object (__webpack_modules__)\n            /******/__webpack_require__.m = modules;\n\n            /******/ // expose the module cache\n            /******/__webpack_require__.c = installedModules;\n\n            /******/ // __webpack_public_path__\n            /******/__webpack_require__.p = \"\";\n\n            /******/ // Load entry module and return exports\n            /******/return __webpack_require__(0);\n            /******/\n          }(\n          /************************************************************************/\n          /******/[\n          /* 0 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _interopRequireWildcard = __webpack_require__(1)['default'];\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n\n            var _handlebarsBase = __webpack_require__(3);\n\n            var base = _interopRequireWildcard(_handlebarsBase);\n\n            // Each of these augment the Handlebars object. No need to setup here.\n            // (This is done to easily share code between commonjs and browse envs)\n\n            var _handlebarsSafeString = __webpack_require__(20);\n\n            var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);\n\n            var _handlebarsException = __webpack_require__(5);\n\n            var _handlebarsException2 = _interopRequireDefault(_handlebarsException);\n\n            var _handlebarsUtils = __webpack_require__(4);\n\n            var Utils = _interopRequireWildcard(_handlebarsUtils);\n\n            var _handlebarsRuntime = __webpack_require__(21);\n\n            var runtime = _interopRequireWildcard(_handlebarsRuntime);\n\n            var _handlebarsNoConflict = __webpack_require__(33);\n\n            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);\n\n            // For compatibility and usage outside of module systems, make the Handlebars object a namespace\n            function create() {\n              var hb = new base.HandlebarsEnvironment();\n\n              Utils.extend(hb, base);\n              hb.SafeString = _handlebarsSafeString2['default'];\n              hb.Exception = _handlebarsException2['default'];\n              hb.Utils = Utils;\n              hb.escapeExpression = Utils.escapeExpression;\n\n              hb.VM = runtime;\n              hb.template = function (spec) {\n                return runtime.template(spec, hb);\n              };\n\n              return hb;\n            }\n\n            var inst = create();\n            inst.create = create;\n\n            _handlebarsNoConflict2['default'](inst);\n\n            inst['default'] = inst;\n\n            exports['default'] = inst;\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 1 */\n          /***/function (module, exports) {\n\n            \"use strict\";\n\n            exports[\"default\"] = function (obj) {\n              if (obj && obj.__esModule) {\n                return obj;\n              } else {\n                var newObj = {};\n\n                if (obj != null) {\n                  for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n                  }\n                }\n\n                newObj[\"default\"] = obj;\n                return newObj;\n              }\n            };\n\n            exports.__esModule = true;\n\n            /***/\n          },\n          /* 2 */\n          /***/function (module, exports) {\n\n            \"use strict\";\n\n            exports[\"default\"] = function (obj) {\n              return obj && obj.__esModule ? obj : {\n                \"default\": obj\n              };\n            };\n\n            exports.__esModule = true;\n\n            /***/\n          },\n          /* 3 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n            exports.HandlebarsEnvironment = HandlebarsEnvironment;\n\n            var _utils = __webpack_require__(4);\n\n            var _exception = __webpack_require__(5);\n\n            var _exception2 = _interopRequireDefault(_exception);\n\n            var _helpers = __webpack_require__(9);\n\n            var _decorators = __webpack_require__(17);\n\n            var _logger = __webpack_require__(19);\n\n            var _logger2 = _interopRequireDefault(_logger);\n\n            var VERSION = '4.0.11';\n            exports.VERSION = VERSION;\n            var COMPILER_REVISION = 7;\n\n            exports.COMPILER_REVISION = COMPILER_REVISION;\n            var REVISION_CHANGES = {\n              1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n              2: '== 1.0.0-rc.3',\n              3: '== 1.0.0-rc.4',\n              4: '== 1.x.x',\n              5: '== 2.0.0-alpha.x',\n              6: '>= 2.0.0-beta.1',\n              7: '>= 4.0.0'\n            };\n\n            exports.REVISION_CHANGES = REVISION_CHANGES;\n            var objectType = '[object Object]';\n\n            function HandlebarsEnvironment(helpers, partials, decorators) {\n              this.helpers = helpers || {};\n              this.partials = partials || {};\n              this.decorators = decorators || {};\n\n              _helpers.registerDefaultHelpers(this);\n              _decorators.registerDefaultDecorators(this);\n            }\n\n            HandlebarsEnvironment.prototype = {\n              constructor: HandlebarsEnvironment,\n\n              logger: _logger2['default'],\n              log: _logger2['default'].log,\n\n              registerHelper: function registerHelper(name, fn) {\n                if (_utils.toString.call(name) === objectType) {\n                  if (fn) {\n                    throw new _exception2['default']('Arg not supported with multiple helpers');\n                  }\n                  _utils.extend(this.helpers, name);\n                } else {\n                  this.helpers[name] = fn;\n                }\n              },\n              unregisterHelper: function unregisterHelper(name) {\n                delete this.helpers[name];\n              },\n\n              registerPartial: function registerPartial(name, partial) {\n                if (_utils.toString.call(name) === objectType) {\n                  _utils.extend(this.partials, name);\n                } else {\n                  if (typeof partial === 'undefined') {\n                    throw new _exception2['default']('Attempting to register a partial called \"' + name + '\" as undefined');\n                  }\n                  this.partials[name] = partial;\n                }\n              },\n              unregisterPartial: function unregisterPartial(name) {\n                delete this.partials[name];\n              },\n\n              registerDecorator: function registerDecorator(name, fn) {\n                if (_utils.toString.call(name) === objectType) {\n                  if (fn) {\n                    throw new _exception2['default']('Arg not supported with multiple decorators');\n                  }\n                  _utils.extend(this.decorators, name);\n                } else {\n                  this.decorators[name] = fn;\n                }\n              },\n              unregisterDecorator: function unregisterDecorator(name) {\n                delete this.decorators[name];\n              }\n            };\n\n            var log = _logger2['default'].log;\n\n            exports.log = log;\n            exports.createFrame = _utils.createFrame;\n            exports.logger = _logger2['default'];\n\n            /***/\n          },\n          /* 4 */\n          /***/function (module, exports) {\n\n            'use strict';\n\n            exports.__esModule = true;\n            exports.extend = extend;\n            exports.indexOf = indexOf;\n            exports.escapeExpression = escapeExpression;\n            exports.isEmpty = isEmpty;\n            exports.createFrame = createFrame;\n            exports.blockParams = blockParams;\n            exports.appendContextPath = appendContextPath;\n            var escape = {\n              '&': '&amp;',\n              '<': '&lt;',\n              '>': '&gt;',\n              '\"': '&quot;',\n              \"'\": '&#x27;',\n              '`': '&#x60;',\n              '=': '&#x3D;'\n            };\n\n            var badChars = /[&<>\"'`=]/g,\n                possible = /[&<>\"'`=]/;\n\n            function escapeChar(chr) {\n              return escape[chr];\n            }\n\n            function extend(obj /* , ...source */) {\n              for (var i = 1; i < arguments.length; i++) {\n                for (var key in arguments[i]) {\n                  if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n                    obj[key] = arguments[i][key];\n                  }\n                }\n              }\n\n              return obj;\n            }\n\n            var toString = Object.prototype.toString;\n\n            exports.toString = toString;\n            // Sourced from lodash\n            // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n            /* eslint-disable func-style */\n            var isFunction = function isFunction(value) {\n              return typeof value === 'function';\n            };\n            // fallback for older versions of Chrome and Safari\n            /* istanbul ignore next */\n            if (isFunction(/x/)) {\n              exports.isFunction = isFunction = function isFunction(value) {\n                return typeof value === 'function' && toString.call(value) === '[object Function]';\n              };\n            }\n            exports.isFunction = isFunction;\n\n            /* eslint-enable func-style */\n\n            /* istanbul ignore next */\n            var isArray = Array.isArray || function (value) {\n              return value && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) === 'object' ? toString.call(value) === '[object Array]' : false;\n            };\n\n            exports.isArray = isArray;\n            // Older IE versions do not directly support indexOf so we must implement our own, sadly.\n\n            function indexOf(array, value) {\n              for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                  return i;\n                }\n              }\n              return -1;\n            }\n\n            function escapeExpression(string) {\n              if (typeof string !== 'string') {\n                // don't escape SafeStrings, since they're already safe\n                if (string && string.toHTML) {\n                  return string.toHTML();\n                } else if (string == null) {\n                  return '';\n                } else if (!string) {\n                  return string + '';\n                }\n\n                // Force a string conversion as this will be done by the append regardless and\n                // the regex test will do this transparently behind the scenes, causing issues if\n                // an object's to string has escaped characters in it.\n                string = '' + string;\n              }\n\n              if (!possible.test(string)) {\n                return string;\n              }\n              return string.replace(badChars, escapeChar);\n            }\n\n            function isEmpty(value) {\n              if (!value && value !== 0) {\n                return true;\n              } else if (isArray(value) && value.length === 0) {\n                return true;\n              } else {\n                return false;\n              }\n            }\n\n            function createFrame(object) {\n              var frame = extend({}, object);\n              frame._parent = object;\n              return frame;\n            }\n\n            function blockParams(params, ids) {\n              params.path = ids;\n              return params;\n            }\n\n            function appendContextPath(contextPath, id) {\n              return (contextPath ? contextPath + '.' : '') + id;\n            }\n\n            /***/\n          },\n          /* 5 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _Object$defineProperty = __webpack_require__(6)['default'];\n\n            exports.__esModule = true;\n\n            var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\n            function Exception(message, node) {\n              var loc = node && node.loc,\n                  line = undefined,\n                  column = undefined;\n              if (loc) {\n                line = loc.start.line;\n                column = loc.start.column;\n\n                message += ' - ' + line + ':' + column;\n              }\n\n              var tmp = Error.prototype.constructor.call(this, message);\n\n              // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n              for (var idx = 0; idx < errorProps.length; idx++) {\n                this[errorProps[idx]] = tmp[errorProps[idx]];\n              }\n\n              /* istanbul ignore else */\n              if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, Exception);\n              }\n\n              try {\n                if (loc) {\n                  this.lineNumber = line;\n\n                  // Work around issue under safari where we can't directly set the column value\n                  /* istanbul ignore next */\n                  if (_Object$defineProperty) {\n                    Object.defineProperty(this, 'column', {\n                      value: column,\n                      enumerable: true\n                    });\n                  } else {\n                    this.column = column;\n                  }\n                }\n              } catch (nop) {\n                /* Ignore if the browser is very particular */\n              }\n            }\n\n            Exception.prototype = new Error();\n\n            exports['default'] = Exception;\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 6 */\n          /***/function (module, exports, __webpack_require__) {\n\n            module.exports = { \"default\": __webpack_require__(7), __esModule: true };\n\n            /***/\n          },\n          /* 7 */\n          /***/function (module, exports, __webpack_require__) {\n\n            var $ = __webpack_require__(8);\n            module.exports = function defineProperty(it, key, desc) {\n              return $.setDesc(it, key, desc);\n            };\n\n            /***/\n          },\n          /* 8 */\n          /***/function (module, exports) {\n\n            var $Object = Object;\n            module.exports = {\n              create: $Object.create,\n              getProto: $Object.getPrototypeOf,\n              isEnum: {}.propertyIsEnumerable,\n              getDesc: $Object.getOwnPropertyDescriptor,\n              setDesc: $Object.defineProperty,\n              setDescs: $Object.defineProperties,\n              getKeys: $Object.keys,\n              getNames: $Object.getOwnPropertyNames,\n              getSymbols: $Object.getOwnPropertySymbols,\n              each: [].forEach\n            };\n\n            /***/\n          },\n          /* 9 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n            exports.registerDefaultHelpers = registerDefaultHelpers;\n\n            var _helpersBlockHelperMissing = __webpack_require__(10);\n\n            var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);\n\n            var _helpersEach = __webpack_require__(11);\n\n            var _helpersEach2 = _interopRequireDefault(_helpersEach);\n\n            var _helpersHelperMissing = __webpack_require__(12);\n\n            var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);\n\n            var _helpersIf = __webpack_require__(13);\n\n            var _helpersIf2 = _interopRequireDefault(_helpersIf);\n\n            var _helpersLog = __webpack_require__(14);\n\n            var _helpersLog2 = _interopRequireDefault(_helpersLog);\n\n            var _helpersLookup = __webpack_require__(15);\n\n            var _helpersLookup2 = _interopRequireDefault(_helpersLookup);\n\n            var _helpersWith = __webpack_require__(16);\n\n            var _helpersWith2 = _interopRequireDefault(_helpersWith);\n\n            function registerDefaultHelpers(instance) {\n              _helpersBlockHelperMissing2['default'](instance);\n              _helpersEach2['default'](instance);\n              _helpersHelperMissing2['default'](instance);\n              _helpersIf2['default'](instance);\n              _helpersLog2['default'](instance);\n              _helpersLookup2['default'](instance);\n              _helpersWith2['default'](instance);\n            }\n\n            /***/\n          },\n          /* 10 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _utils = __webpack_require__(4);\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('blockHelperMissing', function (context, options) {\n                var inverse = options.inverse,\n                    fn = options.fn;\n\n                if (context === true) {\n                  return fn(this);\n                } else if (context === false || context == null) {\n                  return inverse(this);\n                } else if (_utils.isArray(context)) {\n                  if (context.length > 0) {\n                    if (options.ids) {\n                      options.ids = [options.name];\n                    }\n\n                    return instance.helpers.each(context, options);\n                  } else {\n                    return inverse(this);\n                  }\n                } else {\n                  if (options.data && options.ids) {\n                    var data = _utils.createFrame(options.data);\n                    data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n                    options = { data: data };\n                  }\n\n                  return fn(context, options);\n                }\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 11 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n\n            var _utils = __webpack_require__(4);\n\n            var _exception = __webpack_require__(5);\n\n            var _exception2 = _interopRequireDefault(_exception);\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('each', function (context, options) {\n                if (!options) {\n                  throw new _exception2['default']('Must pass iterator to #each');\n                }\n\n                var fn = options.fn,\n                    inverse = options.inverse,\n                    i = 0,\n                    ret = '',\n                    data = undefined,\n                    contextPath = undefined;\n\n                if (options.data && options.ids) {\n                  contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n                }\n\n                if (_utils.isFunction(context)) {\n                  context = context.call(this);\n                }\n\n                if (options.data) {\n                  data = _utils.createFrame(options.data);\n                }\n\n                function execIteration(field, index, last) {\n                  if (data) {\n                    data.key = field;\n                    data.index = index;\n                    data.first = index === 0;\n                    data.last = !!last;\n\n                    if (contextPath) {\n                      data.contextPath = contextPath + field;\n                    }\n                  }\n\n                  ret = ret + fn(context[field], {\n                    data: data,\n                    blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n                  });\n                }\n\n                if (context && (typeof context === 'undefined' ? 'undefined' : _typeof2(context)) === 'object') {\n                  if (_utils.isArray(context)) {\n                    for (var j = context.length; i < j; i++) {\n                      if (i in context) {\n                        execIteration(i, i, i === context.length - 1);\n                      }\n                    }\n                  } else {\n                    var priorKey = undefined;\n\n                    for (var key in context) {\n                      if (context.hasOwnProperty(key)) {\n                        // We're running the iterations one step out of sync so we can detect\n                        // the last iteration without have to scan the object twice and create\n                        // an itermediate keys array.\n                        if (priorKey !== undefined) {\n                          execIteration(priorKey, i - 1);\n                        }\n                        priorKey = key;\n                        i++;\n                      }\n                    }\n                    if (priorKey !== undefined) {\n                      execIteration(priorKey, i - 1, true);\n                    }\n                  }\n                }\n\n                if (i === 0) {\n                  ret = inverse(this);\n                }\n\n                return ret;\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 12 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n\n            var _exception = __webpack_require__(5);\n\n            var _exception2 = _interopRequireDefault(_exception);\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('helperMissing', function () /* [args, ]options */{\n                if (arguments.length === 1) {\n                  // A missing field in a {{foo}} construct.\n                  return undefined;\n                } else {\n                  // Someone is actually trying to call something, blow up.\n                  throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n                }\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 13 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _utils = __webpack_require__(4);\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('if', function (conditional, options) {\n                if (_utils.isFunction(conditional)) {\n                  conditional = conditional.call(this);\n                }\n\n                // Default behavior is to render the positive path if the value is truthy and not empty.\n                // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n                // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n                if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n                  return options.inverse(this);\n                } else {\n                  return options.fn(this);\n                }\n              });\n\n              instance.registerHelper('unless', function (conditional, options) {\n                return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 14 */\n          /***/function (module, exports) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('log', function () /* message, options */{\n                var args = [undefined],\n                    options = arguments[arguments.length - 1];\n                for (var i = 0; i < arguments.length - 1; i++) {\n                  args.push(arguments[i]);\n                }\n\n                var level = 1;\n                if (options.hash.level != null) {\n                  level = options.hash.level;\n                } else if (options.data && options.data.level != null) {\n                  level = options.data.level;\n                }\n                args[0] = level;\n\n                instance.log.apply(instance, args);\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 15 */\n          /***/function (module, exports) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('lookup', function (obj, field) {\n                return obj && obj[field];\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 16 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _utils = __webpack_require__(4);\n\n            exports['default'] = function (instance) {\n              instance.registerHelper('with', function (context, options) {\n                if (_utils.isFunction(context)) {\n                  context = context.call(this);\n                }\n\n                var fn = options.fn;\n\n                if (!_utils.isEmpty(context)) {\n                  var data = options.data;\n                  if (options.data && options.ids) {\n                    data = _utils.createFrame(options.data);\n                    data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n                  }\n\n                  return fn(context, {\n                    data: data,\n                    blockParams: _utils.blockParams([context], [data && data.contextPath])\n                  });\n                } else {\n                  return options.inverse(this);\n                }\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 17 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n            exports.registerDefaultDecorators = registerDefaultDecorators;\n\n            var _decoratorsInline = __webpack_require__(18);\n\n            var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);\n\n            function registerDefaultDecorators(instance) {\n              _decoratorsInline2['default'](instance);\n            }\n\n            /***/\n          },\n          /* 18 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _utils = __webpack_require__(4);\n\n            exports['default'] = function (instance) {\n              instance.registerDecorator('inline', function (fn, props, container, options) {\n                var ret = fn;\n                if (!props.partials) {\n                  props.partials = {};\n                  ret = function ret(context, options) {\n                    // Create a new partials stack frame prior to exec.\n                    var original = container.partials;\n                    container.partials = _utils.extend({}, original, props.partials);\n                    var ret = fn(context, options);\n                    container.partials = original;\n                    return ret;\n                  };\n                }\n\n                props.partials[options.args[0]] = options.fn;\n\n                return ret;\n              });\n            };\n\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 19 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            exports.__esModule = true;\n\n            var _utils = __webpack_require__(4);\n\n            var logger = {\n              methodMap: ['debug', 'info', 'warn', 'error'],\n              level: 'info',\n\n              // Maps a given level value to the `methodMap` indexes above.\n              lookupLevel: function lookupLevel(level) {\n                if (typeof level === 'string') {\n                  var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());\n                  if (levelMap >= 0) {\n                    level = levelMap;\n                  } else {\n                    level = parseInt(level, 10);\n                  }\n                }\n\n                return level;\n              },\n\n              // Can be overridden in the host environment\n              log: function log(level) {\n                level = logger.lookupLevel(level);\n\n                if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n                  var method = logger.methodMap[level];\n                  if (!console[method]) {\n                    // eslint-disable-line no-console\n                    method = 'log';\n                  }\n\n                  for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    message[_key - 1] = arguments[_key];\n                  }\n\n                  console[method].apply(console, message); // eslint-disable-line no-console\n                }\n              }\n            };\n\n            exports['default'] = logger;\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 20 */\n          /***/function (module, exports) {\n\n            // Build out our basic SafeString type\n            'use strict';\n\n            exports.__esModule = true;\n            function SafeString(string) {\n              this.string = string;\n            }\n\n            SafeString.prototype.toString = SafeString.prototype.toHTML = function () {\n              return '' + this.string;\n            };\n\n            exports['default'] = SafeString;\n            module.exports = exports['default'];\n\n            /***/\n          },\n          /* 21 */\n          /***/function (module, exports, __webpack_require__) {\n\n            'use strict';\n\n            var _Object$seal = __webpack_require__(22)['default'];\n\n            var _interopRequireWildcard = __webpack_require__(1)['default'];\n\n            var _interopRequireDefault = __webpack_require__(2)['default'];\n\n            exports.__esModule = true;\n            exports.checkRevision = checkRevision;\n            exports.template = template;\n            exports.wrapProgram = wrapProgram;\n            exports.resolvePartial = resolvePartial;\n            exports.invokePartial = invokePartial;\n            exports.noop = noop;\n\n            var _utils = __webpack_require__(4);\n\n            var Utils = _interopRequireWildcard(_utils);\n\n            var _exception = __webpack_require__(5);\n\n            var _exception2 = _interopRequireDefault(_exception);\n\n            var _base = __webpack_require__(3);\n\n            function checkRevision(compilerInfo) {\n              var compilerRevision = compilerInfo && compilerInfo[0] || 1,\n                  currentRevision = _base.COMPILER_REVISION;\n\n              if (compilerRevision !== currentRevision) {\n                if (compilerRevision < currentRevision) {\n                  var runtimeVersions = _base.REVISION_CHANGES[currentRevision],\n                      compilerVersions = _base.REVISION_CHANGES[compilerRevision];\n                  throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n                } else {\n                  // Use the embedded version info since the runtime doesn't know about this revision yet\n                  throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n                }\n              }\n            }\n\n            function template(templateSpec, env) {\n              /* istanbul ignore next */\n              if (!env) {\n                throw new _exception2['default']('No environment passed to template');\n              }\n              if (!templateSpec || !templateSpec.main) {\n                throw new _exception2['default']('Unknown template object: ' + (typeof templateSpec === 'undefined' ? 'undefined' : _typeof2(templateSpec)));\n              }\n\n              templateSpec.main.decorator = templateSpec.main_d;\n\n              // Note: Using env.VM references rather than local var references throughout this section to allow\n              // for external users to override these as psuedo-supported APIs.\n              env.VM.checkRevision(templateSpec.compiler);\n\n              function invokePartialWrapper(partial, context, options) {\n                if (options.hash) {\n                  context = Utils.extend({}, context, options.hash);\n                  if (options.ids) {\n                    options.ids[0] = true;\n                  }\n                }\n\n                partial = env.VM.resolvePartial.call(this, partial, context, options);\n                var result = env.VM.invokePartial.call(this, partial, context, options);\n\n                if (result == null && env.compile) {\n                  options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);\n                  result = options.partials[options.name](context, options);\n                }\n                if (result != null) {\n                  if (options.indent) {\n                    var lines = result.split('\\n');\n                    for (var i = 0, l = lines.length; i < l; i++) {\n                      if (!lines[i] && i + 1 === l) {\n                        break;\n                      }\n\n                      lines[i] = options.indent + lines[i];\n                    }\n                    result = lines.join('\\n');\n                  }\n                  return result;\n                } else {\n                  throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n                }\n              }\n\n              // Just add water\n              var container = {\n                strict: function strict(obj, name) {\n                  if (!(name in obj)) {\n                    throw new _exception2['default']('\"' + name + '\" not defined in ' + obj);\n                  }\n                  return obj[name];\n                },\n                lookup: function lookup(depths, name) {\n                  var len = depths.length;\n                  for (var i = 0; i < len; i++) {\n                    if (depths[i] && depths[i][name] != null) {\n                      return depths[i][name];\n                    }\n                  }\n                },\n                lambda: function lambda(current, context) {\n                  return typeof current === 'function' ? current.call(context) : current;\n                },\n\n                escapeExpression: Utils.escapeExpression,\n                invokePartial: invokePartialWrapper,\n\n                fn: function fn(i) {\n                  var ret = templateSpec[i];\n                  ret.decorator = templateSpec[i + '_d'];\n                  return ret;\n                },\n\n                programs: [],\n                program: function program(i, data, declaredBlockParams, blockParams, depths) {\n                  var programWrapper = this.programs[i],\n                      fn = this.fn(i);\n                  if (data || depths || blockParams || declaredBlockParams) {\n                    programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n                  } else if (!programWrapper) {\n                    programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n                  }\n                  return programWrapper;\n                },\n\n                data: function data(value, depth) {\n                  while (value && depth--) {\n                    value = value._parent;\n                  }\n                  return value;\n                },\n                merge: function merge(param, common) {\n                  var obj = param || common;\n\n                  if (param && common && param !== common) {\n                    obj = Utils.extend({}, common, param);\n                  }\n\n                  return obj;\n                },\n                // An empty object to use as replacement for null-contexts\n                nullContext: _Object$seal({}),\n\n                noop: env.VM.noop,\n                compilerInfo: templateSpec.compiler\n              };\n\n              function ret(context) {\n                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var data = options.data;\n\n                ret._setup(options);\n                if (!options.partial && templateSpec.useData) {\n                  data = initData(context, data);\n                }\n                var depths = undefined,\n                    blockParams = templateSpec.useBlockParams ? [] : undefined;\n                if (templateSpec.useDepths) {\n                  if (options.depths) {\n                    depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;\n                  } else {\n                    depths = [context];\n                  }\n                }\n\n                function main(context /*, options*/) {\n                  return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);\n                }\n                main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);\n                return main(context, options);\n              }\n              ret.isTop = true;\n\n              ret._setup = function (options) {\n                if (!options.partial) {\n                  container.helpers = container.merge(options.helpers, env.helpers);\n\n                  if (templateSpec.usePartial) {\n                    container.partials = container.merge(options.partials, env.partials);\n                  }\n                  if (templateSpec.usePartial || templateSpec.useDecorators) {\n                    container.decorators = container.merge(options.decorators, env.decorators);\n                  }\n                } else {\n                  container.helpers = options.helpers;\n                  container.partials = options.partials;\n                  container.decorators = options.decorators;\n                }\n              };\n\n              ret._child = function (i, data, blockParams, depths) {\n                if (templateSpec.useBlockParams && !blockParams) {\n                  throw new _exception2['default']('must pass block params');\n                }\n                if (templateSpec.useDepths && !depths) {\n                  throw new _exception2['default']('must pass parent depths');\n                }\n\n                return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n              };\n              return ret;\n            }\n\n            function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n              function prog(context) {\n                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var currentDepths = depths;\n                if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {\n                  currentDepths = [context].concat(depths);\n                }\n\n                return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);\n              }\n\n              prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n\n              prog.program = i;\n              prog.depth = depths ? depths.length : 0;\n              prog.blockParams = declaredBlockParams || 0;\n              return prog;\n            }\n\n            function resolvePartial(partial, context, options) {\n              if (!partial) {\n                if (options.name === '@partial-block') {\n                  partial = options.data['partial-block'];\n                } else {\n                  partial = options.partials[options.name];\n                }\n              } else if (!partial.call && !options.name) {\n                // This is a dynamic partial that returned a string\n                options.name = partial;\n                partial = options.partials[partial];\n              }\n              return partial;\n            }\n\n            function invokePartial(partial, context, options) {\n              // Use the current closure context to save the partial-block if this partial\n              var currentPartialBlock = options.data && options.data['partial-block'];\n              options.partial = true;\n              if (options.ids) {\n                options.data.contextPath = options.ids[0] || options.data.contextPath;\n              }\n\n              var partialBlock = undefined;\n              if (options.fn && options.fn !== noop) {\n                (function () {\n                  options.data = _base.createFrame(options.data);\n                  // Wrapper function to get access to currentPartialBlock from the closure\n                  var fn = options.fn;\n                  partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {\n                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                    // Restore the partial-block from the closure for the execution of the block\n                    // i.e. the part inside the block of the partial call.\n                    options.data = _base.createFrame(options.data);\n                    options.data['partial-block'] = currentPartialBlock;\n                    return fn(context, options);\n                  };\n                  if (fn.partials) {\n                    options.partials = Utils.extend({}, options.partials, fn.partials);\n                  }\n                })();\n              }\n\n              if (partial === undefined && partialBlock) {\n                partial = partialBlock;\n              }\n\n              if (partial === undefined) {\n                throw new _exception2['default']('The partial ' + options.name + ' could not be found');\n              } else if (partial instanceof Function) {\n                return partial(context, options);\n              }\n            }\n\n            function noop() {\n              return '';\n            }\n\n            function initData(context, data) {\n              if (!data || !('root' in data)) {\n                data = data ? _base.createFrame(data) : {};\n                data.root = context;\n              }\n              return data;\n            }\n\n            function executeDecorators(fn, prog, container, depths, data, blockParams) {\n              if (fn.decorator) {\n                var props = {};\n                prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);\n                Utils.extend(prog, props);\n              }\n              return prog;\n            }\n\n            /***/\n          },\n          /* 22 */\n          /***/function (module, exports, __webpack_require__) {\n\n            module.exports = { \"default\": __webpack_require__(23), __esModule: true };\n\n            /***/\n          },\n          /* 23 */\n          /***/function (module, exports, __webpack_require__) {\n\n            __webpack_require__(24);\n            module.exports = __webpack_require__(29).Object.seal;\n\n            /***/\n          },\n          /* 24 */\n          /***/function (module, exports, __webpack_require__) {\n\n            // 19.1.2.17 Object.seal(O)\n            var isObject = __webpack_require__(25);\n\n            __webpack_require__(26)('seal', function ($seal) {\n              return function seal(it) {\n                return $seal && isObject(it) ? $seal(it) : it;\n              };\n            });\n\n            /***/\n          },\n          /* 25 */\n          /***/function (module, exports) {\n\n            module.exports = function (it) {\n              return (typeof it === 'undefined' ? 'undefined' : _typeof2(it)) === 'object' ? it !== null : typeof it === 'function';\n            };\n\n            /***/\n          },\n          /* 26 */\n          /***/function (module, exports, __webpack_require__) {\n\n            // most Object methods by ES6 should accept primitives\n            var $export = __webpack_require__(27),\n                core = __webpack_require__(29),\n                fails = __webpack_require__(32);\n            module.exports = function (KEY, exec) {\n              var fn = (core.Object || {})[KEY] || Object[KEY],\n                  exp = {};\n              exp[KEY] = exec(fn);\n              $export($export.S + $export.F * fails(function () {\n                fn(1);\n              }), 'Object', exp);\n            };\n\n            /***/\n          },\n          /* 27 */\n          /***/function (module, exports, __webpack_require__) {\n\n            var global = __webpack_require__(28),\n                core = __webpack_require__(29),\n                ctx = __webpack_require__(30),\n                PROTOTYPE = 'prototype';\n\n            var $export = function $export(type, name, source) {\n              var IS_FORCED = type & $export.F,\n                  IS_GLOBAL = type & $export.G,\n                  IS_STATIC = type & $export.S,\n                  IS_PROTO = type & $export.P,\n                  IS_BIND = type & $export.B,\n                  IS_WRAP = type & $export.W,\n                  exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),\n                  target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],\n                  key,\n                  own,\n                  out;\n              if (IS_GLOBAL) source = name;\n              for (key in source) {\n                // contains in native\n                own = !IS_FORCED && target && key in target;\n                if (own && key in exports) continue;\n                // export native or passed\n                out = own ? target[key] : source[key];\n                // prevent global pollution for namespaces\n                exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n                // bind timers to global for call from export context\n                : IS_BIND && own ? ctx(out, global)\n                // wrap global constructors for prevent change them in library\n                : IS_WRAP && target[key] == out ? function (C) {\n                  var F = function F(param) {\n                    return this instanceof C ? new C(param) : C(param);\n                  };\n                  F[PROTOTYPE] = C[PROTOTYPE];\n                  return F;\n                  // make static versions for prototype methods\n                }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n                if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n              }\n            };\n            // type bitmap\n            $export.F = 1; // forced\n            $export.G = 2; // global\n            $export.S = 4; // static\n            $export.P = 8; // proto\n            $export.B = 16; // bind\n            $export.W = 32; // wrap\n            module.exports = $export;\n\n            /***/\n          },\n          /* 28 */\n          /***/function (module, exports) {\n\n            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n            var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n            if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n            /***/\n          },\n          /* 29 */\n          /***/function (module, exports) {\n\n            var core = module.exports = { version: '1.2.6' };\n            if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n            /***/\n          },\n          /* 30 */\n          /***/function (module, exports, __webpack_require__) {\n\n            // optional / simple context binding\n            var aFunction = __webpack_require__(31);\n            module.exports = function (fn, that, length) {\n              aFunction(fn);\n              if (that === undefined) return fn;\n              switch (length) {\n                case 1:\n                  return function (a) {\n                    return fn.call(that, a);\n                  };\n                case 2:\n                  return function (a, b) {\n                    return fn.call(that, a, b);\n                  };\n                case 3:\n                  return function (a, b, c) {\n                    return fn.call(that, a, b, c);\n                  };\n              }\n              return function () /* ...args */{\n                return fn.apply(that, arguments);\n              };\n            };\n\n            /***/\n          },\n          /* 31 */\n          /***/function (module, exports) {\n\n            module.exports = function (it) {\n              if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n              return it;\n            };\n\n            /***/\n          },\n          /* 32 */\n          /***/function (module, exports) {\n\n            module.exports = function (exec) {\n              try {\n                return !!exec();\n              } catch (e) {\n                return true;\n              }\n            };\n\n            /***/\n          },\n          /* 33 */\n          /***/function (module, exports) {\n\n            /* WEBPACK VAR INJECTION */(function (global) {\n              /* global window */\n              'use strict';\n\n              exports.__esModule = true;\n\n              exports['default'] = function (Handlebars) {\n                /* istanbul ignore next */\n                var root = typeof global !== 'undefined' ? global : window,\n                    $Handlebars = root.Handlebars;\n                /* istanbul ignore next */\n                Handlebars.noConflict = function () {\n                  if (root.Handlebars === Handlebars) {\n                    root.Handlebars = $Handlebars;\n                  }\n                  return Handlebars;\n                };\n              };\n\n              module.exports = exports['default'];\n              /* WEBPACK VAR INJECTION */\n            }).call(exports, function () {\n              return this;\n            }());\n\n            /***/\n          }]\n          /******/)\n        );\n      });\n      ;\n\n      /***/\n    },,,\n    /* 1 */\n    /* 2 */\n    /* 3 */\n    /***/function (module, exports) {\n\n      // removed by extract-text-webpack-plugin\n      module.exports = { \"custom-alert\": \"custom-alert\", \"custom-alert-content\": \"custom-alert-content\", \"custom-alert-title\": \"custom-alert-title\", \"title-online\": \"title-online\", \"custom-tip-single\": \"custom-tip-single\", \"custom-alert-msg\": \"custom-alert-msg\", \"title-padding-two\": \"title-padding-two\", \"custom-alert-btn-group\": \"custom-alert-btn-group\", \"custom-alert-btn\": \"custom-alert-btn\", \"custom-type-alert\": \"custom-type-alert\", \"custom-alert-ok\": \"custom-alert-ok\", \"custom-type-warning\": \"custom-type-warning\", \"custom-alert-cancel\": \"custom-alert-cancel\", \"custom-alert-mask\": \"custom-alert-mask\", \"in\": \"in\", \"bounceIn\": \"bounceIn\", \"out\": \"out\", \"bounceOut\": \"bounceOut\", \"fn-hide\": \"fn-hide\" };\n\n      /***/\n    },,,,\n    /* 4 */\n    /* 5 */\n    /* 6 */\n    /* 7 */\n    /***/function (module, exports, __webpack_require__) {\n\n      var Handlebars = __webpack_require__(0);\n      function __default(obj) {\n        return obj && (obj.__esModule ? obj[\"default\"] : obj);\n      }\n      module.exports = (Handlebars[\"default\"] || Handlebars).template({ \"1\": function _(container, depth0, helpers, partials, data) {\n          return \"            <p class=\\\"custom-alert-title\\\">\" + container.escapeExpression(container.lambda(depth0, depth0)) + \"</p>\\n\";\n        }, \"3\": function _(container, depth0, helpers, partials, data, blockParams, depths) {\n          var alias1 = container.lambda,\n              alias2 = container.escapeExpression;\n\n          return \"                <p class=\\\"custom-alert-msg \" + alias2(alias1(depths[1] != null ? depths[1].isHide : depths[1], depth0)) + \"\\\">\" + alias2(alias1(depth0, depth0)) + \"</p>\\n\";\n        }, \"5\": function _(container, depth0, helpers, partials, data) {\n          var stack1, helper;\n\n          return \"            <div class=\\\"custom-alert-html\\\">\\n                \" + ((stack1 = (helper = (helper = helpers.appendHtml || (depth0 != null ? depth0.appendHtml : depth0)) != null ? helper : helpers.helperMissing, typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { \"name\": \"appendHtml\", \"hash\": {}, \"data\": data }) : helper)) != null ? stack1 : \"\") + \"\\n            </div>\\n\";\n        }, \"7\": function _(container, depth0, helpers, partials, data) {\n          var helper;\n\n          return \"                <a href=\\\"javascript:void(0)\\\" class=\\\"custom-alert-btn custom-alert-cancel\\\">\" + container.escapeExpression((helper = (helper = helpers.cancelText || (depth0 != null ? depth0.cancelText : depth0)) != null ? helper : helpers.helperMissing, typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { \"name\": \"cancelText\", \"hash\": {}, \"data\": data }) : helper)) + \"</a>\\n\";\n        }, \"compiler\": [7, \">= 4.0.0\"], \"main\": function main(container, depth0, helpers, partials, data, blockParams, depths) {\n          var stack1,\n              helper,\n              alias1 = depth0 != null ? depth0 : container.nullContext || {},\n              alias2 = helpers.helperMissing,\n              alias3 = \"function\",\n              alias4 = container.escapeExpression;\n\n          return \"<div>\\n    <div class=\\\"custom-alert in custom-type-\" + alias4((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof2(helper)) === alias3 ? helper.call(alias1, { \"name\": \"type\", \"hash\": {}, \"data\": data }) : helper)) + \"\\\">\\n        <div class=\\\"custom-alert-content \" + alias4((helper = (helper = helpers.titleClassName || (depth0 != null ? depth0.titleClassName : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof2(helper)) === alias3 ? helper.call(alias1, { \"name\": \"titleClassName\", \"hash\": {}, \"data\": data }) : helper)) + \" \" + alias4((helper = (helper = helpers.contentClassName || (depth0 != null ? depth0.contentClassName : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof2(helper)) === alias3 ? helper.call(alias1, { \"name\": \"contentClassName\", \"hash\": {}, \"data\": data }) : helper)) + \"\\\">\\n\" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.titleALL : depth0, { \"name\": \"each\", \"hash\": {}, \"fn\": container.program(1, data, 0, blockParams, depths), \"inverse\": container.noop, \"data\": data })) != null ? stack1 : \"\") + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.tips : depth0, { \"name\": \"each\", \"hash\": {}, \"fn\": container.program(3, data, 0, blockParams, depths), \"inverse\": container.noop, \"data\": data })) != null ? stack1 : \"\") + \"\\n\" + ((stack1 = helpers[\"if\"].call(alias1, depth0 != null ? depth0.appendHtml : depth0, { \"name\": \"if\", \"hash\": {}, \"fn\": container.program(5, data, 0, blockParams, depths), \"inverse\": container.noop, \"data\": data })) != null ? stack1 : \"\") + \"        </div>\\n        <div class=\\\"custom-alert-btn-group\\\">\\n\" + ((stack1 = helpers[\"if\"].call(alias1, depth0 != null ? depth0.showCancel : depth0, { \"name\": \"if\", \"hash\": {}, \"fn\": container.program(7, data, 0, blockParams, depths), \"inverse\": container.noop, \"data\": data })) != null ? stack1 : \"\") + \"            <a href=\\\"javascript:void(0)\\\" class=\\\"custom-alert-btn custom-alert-ok\\\">\" + alias4((helper = (helper = helpers.okText || (depth0 != null ? depth0.okText : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof2(helper)) === alias3 ? helper.call(alias1, { \"name\": \"okText\", \"hash\": {}, \"data\": data }) : helper)) + \"</a>\\n        </div>\\n    </div>\\n    <div class=\\\"custom-alert-mask\\\">\\n    </div>\\n</div>\\n\\n\";\n        }, \"useData\": true, \"useDepths\": true });\n\n      /***/\n    },,,\n    /* 8 */\n    /* 9 */\n    /* 10 */\n    /***/function (module, exports, __webpack_require__) {\n\n      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; //     Underscore.js 1.8.3\n      //     http://underscorejs.org\n      //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n      //     Underscore may be freely distributed under the MIT license.\n\n      (function () {\n\n        // Baseline setup\n        // --------------\n\n        // Establish the root object, `window` in the browser, or `exports` on the server.\n        var root = this;\n\n        // Save the previous value of the `_` variable.\n        var previousUnderscore = root._;\n\n        // Save bytes in the minified (but not gzipped) version:\n        var ArrayProto = Array.prototype,\n            ObjProto = Object.prototype,\n            FuncProto = Function.prototype;\n\n        // Create quick reference variables for speed access to core prototypes.\n        var push = ArrayProto.push,\n            slice = ArrayProto.slice,\n            toString = ObjProto.toString,\n            hasOwnProperty = ObjProto.hasOwnProperty;\n\n        // All **ECMAScript 5** native function implementations that we hope to use\n        // are declared here.\n        var nativeIsArray = Array.isArray,\n            nativeKeys = Object.keys,\n            nativeBind = FuncProto.bind,\n            nativeCreate = Object.create;\n\n        // Naked function reference for surrogate-prototype-swapping.\n        var Ctor = function Ctor() {};\n\n        // Create a safe reference to the Underscore object for use below.\n        var _ = function _(obj) {\n          if (obj instanceof _) return obj;\n          if (!(this instanceof _)) return new _(obj);\n          this._wrapped = obj;\n        };\n\n        // Export the Underscore object for **Node.js**, with\n        // backwards-compatibility for the old `require()` API. If we're in\n        // the browser, add `_` as a global object.\n        if (true) {\n          if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = _;\n          }\n          exports._ = _;\n        } else {\n          root._ = _;\n        }\n\n        // Current version.\n        _.VERSION = '1.8.3';\n\n        // Internal function that returns an efficient (for current engines) version\n        // of the passed-in callback, to be repeatedly applied in other Underscore\n        // functions.\n        var optimizeCb = function optimizeCb(func, context, argCount) {\n          if (context === void 0) return func;\n          switch (argCount == null ? 3 : argCount) {\n            case 1:\n              return function (value) {\n                return func.call(context, value);\n              };\n            case 2:\n              return function (value, other) {\n                return func.call(context, value, other);\n              };\n            case 3:\n              return function (value, index, collection) {\n                return func.call(context, value, index, collection);\n              };\n            case 4:\n              return function (accumulator, value, index, collection) {\n                return func.call(context, accumulator, value, index, collection);\n              };\n          }\n          return function () {\n            return func.apply(context, arguments);\n          };\n        };\n\n        // A mostly-internal function to generate callbacks that can be applied\n        // to each element in a collection, returning the desired result — either\n        // identity, an arbitrary callback, a property matcher, or a property accessor.\n        var cb = function cb(value, context, argCount) {\n          if (value == null) return _.identity;\n          if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n          if (_.isObject(value)) return _.matcher(value);\n          return _.property(value);\n        };\n        _.iteratee = function (value, context) {\n          return cb(value, context, Infinity);\n        };\n\n        // An internal function for creating assigner functions.\n        var createAssigner = function createAssigner(keysFunc, undefinedOnly) {\n          return function (obj) {\n            var length = arguments.length;\n            if (length < 2 || obj == null) return obj;\n            for (var index = 1; index < length; index++) {\n              var source = arguments[index],\n                  keys = keysFunc(source),\n                  l = keys.length;\n              for (var i = 0; i < l; i++) {\n                var key = keys[i];\n                if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n              }\n            }\n            return obj;\n          };\n        };\n\n        // An internal function for creating a new object that inherits from another.\n        var baseCreate = function baseCreate(prototype) {\n          if (!_.isObject(prototype)) return {};\n          if (nativeCreate) return nativeCreate(prototype);\n          Ctor.prototype = prototype;\n          var result = new Ctor();\n          Ctor.prototype = null;\n          return result;\n        };\n\n        var property = function property(key) {\n          return function (obj) {\n            return obj == null ? void 0 : obj[key];\n          };\n        };\n\n        // Helper for collection methods to determine whether a collection\n        // should be iterated as an array or as an object\n        // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n        // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n        var getLength = property('length');\n        var isArrayLike = function isArrayLike(collection) {\n          var length = getLength(collection);\n          return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n        };\n\n        // Collection Functions\n        // --------------------\n\n        // The cornerstone, an `each` implementation, aka `forEach`.\n        // Handles raw objects in addition to array-likes. Treats all\n        // sparse array-likes as if they were dense.\n        _.each = _.forEach = function (obj, iteratee, context) {\n          iteratee = optimizeCb(iteratee, context);\n          var i, length;\n          if (isArrayLike(obj)) {\n            for (i = 0, length = obj.length; i < length; i++) {\n              iteratee(obj[i], i, obj);\n            }\n          } else {\n            var keys = _.keys(obj);\n            for (i = 0, length = keys.length; i < length; i++) {\n              iteratee(obj[keys[i]], keys[i], obj);\n            }\n          }\n          return obj;\n        };\n\n        // Return the results of applying the iteratee to each element.\n        _.map = _.collect = function (obj, iteratee, context) {\n          iteratee = cb(iteratee, context);\n          var keys = !isArrayLike(obj) && _.keys(obj),\n              length = (keys || obj).length,\n              results = Array(length);\n          for (var index = 0; index < length; index++) {\n            var currentKey = keys ? keys[index] : index;\n            results[index] = iteratee(obj[currentKey], currentKey, obj);\n          }\n          return results;\n        };\n\n        // Create a reducing function iterating left or right.\n        function createReduce(dir) {\n          // Optimized iterator function as using arguments.length\n          // in the main function will deoptimize the, see #1991.\n          function iterator(obj, iteratee, memo, keys, index, length) {\n            for (; index >= 0 && index < length; index += dir) {\n              var currentKey = keys ? keys[index] : index;\n              memo = iteratee(memo, obj[currentKey], currentKey, obj);\n            }\n            return memo;\n          }\n\n          return function (obj, iteratee, memo, context) {\n            iteratee = optimizeCb(iteratee, context, 4);\n            var keys = !isArrayLike(obj) && _.keys(obj),\n                length = (keys || obj).length,\n                index = dir > 0 ? 0 : length - 1;\n            // Determine the initial value if none is provided.\n            if (arguments.length < 3) {\n              memo = obj[keys ? keys[index] : index];\n              index += dir;\n            }\n            return iterator(obj, iteratee, memo, keys, index, length);\n          };\n        }\n\n        // **Reduce** builds up a single result from a list of values, aka `inject`,\n        // or `foldl`.\n        _.reduce = _.foldl = _.inject = createReduce(1);\n\n        // The right-associative version of reduce, also known as `foldr`.\n        _.reduceRight = _.foldr = createReduce(-1);\n\n        // Return the first value which passes a truth test. Aliased as `detect`.\n        _.find = _.detect = function (obj, predicate, context) {\n          var key;\n          if (isArrayLike(obj)) {\n            key = _.findIndex(obj, predicate, context);\n          } else {\n            key = _.findKey(obj, predicate, context);\n          }\n          if (key !== void 0 && key !== -1) return obj[key];\n        };\n\n        // Return all the elements that pass a truth test.\n        // Aliased as `select`.\n        _.filter = _.select = function (obj, predicate, context) {\n          var results = [];\n          predicate = cb(predicate, context);\n          _.each(obj, function (value, index, list) {\n            if (predicate(value, index, list)) results.push(value);\n          });\n          return results;\n        };\n\n        // Return all the elements for which a truth test fails.\n        _.reject = function (obj, predicate, context) {\n          return _.filter(obj, _.negate(cb(predicate)), context);\n        };\n\n        // Determine whether all of the elements match a truth test.\n        // Aliased as `all`.\n        _.every = _.all = function (obj, predicate, context) {\n          predicate = cb(predicate, context);\n          var keys = !isArrayLike(obj) && _.keys(obj),\n              length = (keys || obj).length;\n          for (var index = 0; index < length; index++) {\n            var currentKey = keys ? keys[index] : index;\n            if (!predicate(obj[currentKey], currentKey, obj)) return false;\n          }\n          return true;\n        };\n\n        // Determine if at least one element in the object matches a truth test.\n        // Aliased as `any`.\n        _.some = _.any = function (obj, predicate, context) {\n          predicate = cb(predicate, context);\n          var keys = !isArrayLike(obj) && _.keys(obj),\n              length = (keys || obj).length;\n          for (var index = 0; index < length; index++) {\n            var currentKey = keys ? keys[index] : index;\n            if (predicate(obj[currentKey], currentKey, obj)) return true;\n          }\n          return false;\n        };\n\n        // Determine if the array or object contains a given item (using `===`).\n        // Aliased as `includes` and `include`.\n        _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {\n          if (!isArrayLike(obj)) obj = _.values(obj);\n          if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n          return _.indexOf(obj, item, fromIndex) >= 0;\n        };\n\n        // Invoke a method (with arguments) on every item in a collection.\n        _.invoke = function (obj, method) {\n          var args = slice.call(arguments, 2);\n          var isFunc = _.isFunction(method);\n          return _.map(obj, function (value) {\n            var func = isFunc ? method : value[method];\n            return func == null ? func : func.apply(value, args);\n          });\n        };\n\n        // Convenience version of a common use case of `map`: fetching a property.\n        _.pluck = function (obj, key) {\n          return _.map(obj, _.property(key));\n        };\n\n        // Convenience version of a common use case of `filter`: selecting only objects\n        // containing specific `key:value` pairs.\n        _.where = function (obj, attrs) {\n          return _.filter(obj, _.matcher(attrs));\n        };\n\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        _.findWhere = function (obj, attrs) {\n          return _.find(obj, _.matcher(attrs));\n        };\n\n        // Return the maximum element (or element-based computation).\n        _.max = function (obj, iteratee, context) {\n          var result = -Infinity,\n              lastComputed = -Infinity,\n              value,\n              computed;\n          if (iteratee == null && obj != null) {\n            obj = isArrayLike(obj) ? obj : _.values(obj);\n            for (var i = 0, length = obj.length; i < length; i++) {\n              value = obj[i];\n              if (value > result) {\n                result = value;\n              }\n            }\n          } else {\n            iteratee = cb(iteratee, context);\n            _.each(obj, function (value, index, list) {\n              computed = iteratee(value, index, list);\n              if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n                result = value;\n                lastComputed = computed;\n              }\n            });\n          }\n          return result;\n        };\n\n        // Return the minimum element (or element-based computation).\n        _.min = function (obj, iteratee, context) {\n          var result = Infinity,\n              lastComputed = Infinity,\n              value,\n              computed;\n          if (iteratee == null && obj != null) {\n            obj = isArrayLike(obj) ? obj : _.values(obj);\n            for (var i = 0, length = obj.length; i < length; i++) {\n              value = obj[i];\n              if (value < result) {\n                result = value;\n              }\n            }\n          } else {\n            iteratee = cb(iteratee, context);\n            _.each(obj, function (value, index, list) {\n              computed = iteratee(value, index, list);\n              if (computed < lastComputed || computed === Infinity && result === Infinity) {\n                result = value;\n                lastComputed = computed;\n              }\n            });\n          }\n          return result;\n        };\n\n        // Shuffle a collection, using the modern version of the\n        // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n        _.shuffle = function (obj) {\n          var set = isArrayLike(obj) ? obj : _.values(obj);\n          var length = set.length;\n          var shuffled = Array(length);\n          for (var index = 0, rand; index < length; index++) {\n            rand = _.random(0, index);\n            if (rand !== index) shuffled[index] = shuffled[rand];\n            shuffled[rand] = set[index];\n          }\n          return shuffled;\n        };\n\n        // Sample **n** random values from a collection.\n        // If **n** is not specified, returns a single random element.\n        // The internal `guard` argument allows it to work with `map`.\n        _.sample = function (obj, n, guard) {\n          if (n == null || guard) {\n            if (!isArrayLike(obj)) obj = _.values(obj);\n            return obj[_.random(obj.length - 1)];\n          }\n          return _.shuffle(obj).slice(0, Math.max(0, n));\n        };\n\n        // Sort the object's values by a criterion produced by an iteratee.\n        _.sortBy = function (obj, iteratee, context) {\n          iteratee = cb(iteratee, context);\n          return _.pluck(_.map(obj, function (value, index, list) {\n            return {\n              value: value,\n              index: index,\n              criteria: iteratee(value, index, list)\n            };\n          }).sort(function (left, right) {\n            var a = left.criteria;\n            var b = right.criteria;\n            if (a !== b) {\n              if (a > b || a === void 0) return 1;\n              if (a < b || b === void 0) return -1;\n            }\n            return left.index - right.index;\n          }), 'value');\n        };\n\n        // An internal function used for aggregate \"group by\" operations.\n        var group = function group(behavior) {\n          return function (obj, iteratee, context) {\n            var result = {};\n            iteratee = cb(iteratee, context);\n            _.each(obj, function (value, index) {\n              var key = iteratee(value, index, obj);\n              behavior(result, value, key);\n            });\n            return result;\n          };\n        };\n\n        // Groups the object's values by a criterion. Pass either a string attribute\n        // to group by, or a function that returns the criterion.\n        _.groupBy = group(function (result, value, key) {\n          if (_.has(result, key)) result[key].push(value);else result[key] = [value];\n        });\n\n        // Indexes the object's values by a criterion, similar to `groupBy`, but for\n        // when you know that your index values will be unique.\n        _.indexBy = group(function (result, value, key) {\n          result[key] = value;\n        });\n\n        // Counts instances of an object that group by a certain criterion. Pass\n        // either a string attribute to count by, or a function that returns the\n        // criterion.\n        _.countBy = group(function (result, value, key) {\n          if (_.has(result, key)) result[key]++;else result[key] = 1;\n        });\n\n        // Safely create a real, live array from anything iterable.\n        _.toArray = function (obj) {\n          if (!obj) return [];\n          if (_.isArray(obj)) return slice.call(obj);\n          if (isArrayLike(obj)) return _.map(obj, _.identity);\n          return _.values(obj);\n        };\n\n        // Return the number of elements in an object.\n        _.size = function (obj) {\n          if (obj == null) return 0;\n          return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n        };\n\n        // Split a collection into two arrays: one whose elements all satisfy the given\n        // predicate, and one whose elements all do not satisfy the predicate.\n        _.partition = function (obj, predicate, context) {\n          predicate = cb(predicate, context);\n          var pass = [],\n              fail = [];\n          _.each(obj, function (value, key, obj) {\n            (predicate(value, key, obj) ? pass : fail).push(value);\n          });\n          return [pass, fail];\n        };\n\n        // Array Functions\n        // ---------------\n\n        // Get the first element of an array. Passing **n** will return the first N\n        // values in the array. Aliased as `head` and `take`. The **guard** check\n        // allows it to work with `_.map`.\n        _.first = _.head = _.take = function (array, n, guard) {\n          if (array == null) return void 0;\n          if (n == null || guard) return array[0];\n          return _.initial(array, array.length - n);\n        };\n\n        // Returns everything but the last entry of the array. Especially useful on\n        // the arguments object. Passing **n** will return all the values in\n        // the array, excluding the last N.\n        _.initial = function (array, n, guard) {\n          return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n        };\n\n        // Get the last element of an array. Passing **n** will return the last N\n        // values in the array.\n        _.last = function (array, n, guard) {\n          if (array == null) return void 0;\n          if (n == null || guard) return array[array.length - 1];\n          return _.rest(array, Math.max(0, array.length - n));\n        };\n\n        // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n        // Especially useful on the arguments object. Passing an **n** will return\n        // the rest N values in the array.\n        _.rest = _.tail = _.drop = function (array, n, guard) {\n          return slice.call(array, n == null || guard ? 1 : n);\n        };\n\n        // Trim out all falsy values from an array.\n        _.compact = function (array) {\n          return _.filter(array, _.identity);\n        };\n\n        // Internal implementation of a recursive `flatten` function.\n        var flatten = function flatten(input, shallow, strict, startIndex) {\n          var output = [],\n              idx = 0;\n          for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n            var value = input[i];\n            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n              //flatten current level of array or arguments object\n              if (!shallow) value = flatten(value, shallow, strict);\n              var j = 0,\n                  len = value.length;\n              output.length += len;\n              while (j < len) {\n                output[idx++] = value[j++];\n              }\n            } else if (!strict) {\n              output[idx++] = value;\n            }\n          }\n          return output;\n        };\n\n        // Flatten out an array, either recursively (by default), or just one level.\n        _.flatten = function (array, shallow) {\n          return flatten(array, shallow, false);\n        };\n\n        // Return a version of the array that does not contain the specified value(s).\n        _.without = function (array) {\n          return _.difference(array, slice.call(arguments, 1));\n        };\n\n        // Produce a duplicate-free version of the array. If the array has already\n        // been sorted, you have the option of using a faster algorithm.\n        // Aliased as `unique`.\n        _.uniq = _.unique = function (array, isSorted, iteratee, context) {\n          if (!_.isBoolean(isSorted)) {\n            context = iteratee;\n            iteratee = isSorted;\n            isSorted = false;\n          }\n          if (iteratee != null) iteratee = cb(iteratee, context);\n          var result = [];\n          var seen = [];\n          for (var i = 0, length = getLength(array); i < length; i++) {\n            var value = array[i],\n                computed = iteratee ? iteratee(value, i, array) : value;\n            if (isSorted) {\n              if (!i || seen !== computed) result.push(value);\n              seen = computed;\n            } else if (iteratee) {\n              if (!_.contains(seen, computed)) {\n                seen.push(computed);\n                result.push(value);\n              }\n            } else if (!_.contains(result, value)) {\n              result.push(value);\n            }\n          }\n          return result;\n        };\n\n        // Produce an array that contains the union: each distinct element from all of\n        // the passed-in arrays.\n        _.union = function () {\n          return _.uniq(flatten(arguments, true, true));\n        };\n\n        // Produce an array that contains every item shared between all the\n        // passed-in arrays.\n        _.intersection = function (array) {\n          var result = [];\n          var argsLength = arguments.length;\n          for (var i = 0, length = getLength(array); i < length; i++) {\n            var item = array[i];\n            if (_.contains(result, item)) continue;\n            for (var j = 1; j < argsLength; j++) {\n              if (!_.contains(arguments[j], item)) break;\n            }\n            if (j === argsLength) result.push(item);\n          }\n          return result;\n        };\n\n        // Take the difference between one array and a number of other arrays.\n        // Only the elements present in just the first array will remain.\n        _.difference = function (array) {\n          var rest = flatten(arguments, true, true, 1);\n          return _.filter(array, function (value) {\n            return !_.contains(rest, value);\n          });\n        };\n\n        // Zip together multiple lists into a single array -- elements that share\n        // an index go together.\n        _.zip = function () {\n          return _.unzip(arguments);\n        };\n\n        // Complement of _.zip. Unzip accepts an array of arrays and groups\n        // each array's elements on shared indices\n        _.unzip = function (array) {\n          var length = array && _.max(array, getLength).length || 0;\n          var result = Array(length);\n\n          for (var index = 0; index < length; index++) {\n            result[index] = _.pluck(array, index);\n          }\n          return result;\n        };\n\n        // Converts lists into objects. Pass either a single array of `[key, value]`\n        // pairs, or two parallel arrays of the same length -- one of keys, and one of\n        // the corresponding values.\n        _.object = function (list, values) {\n          var result = {};\n          for (var i = 0, length = getLength(list); i < length; i++) {\n            if (values) {\n              result[list[i]] = values[i];\n            } else {\n              result[list[i][0]] = list[i][1];\n            }\n          }\n          return result;\n        };\n\n        // Generator function to create the findIndex and findLastIndex functions\n        function createPredicateIndexFinder(dir) {\n          return function (array, predicate, context) {\n            predicate = cb(predicate, context);\n            var length = getLength(array);\n            var index = dir > 0 ? 0 : length - 1;\n            for (; index >= 0 && index < length; index += dir) {\n              if (predicate(array[index], index, array)) return index;\n            }\n            return -1;\n          };\n        }\n\n        // Returns the first index on an array-like that passes a predicate test\n        _.findIndex = createPredicateIndexFinder(1);\n        _.findLastIndex = createPredicateIndexFinder(-1);\n\n        // Use a comparator function to figure out the smallest index at which\n        // an object should be inserted so as to maintain order. Uses binary search.\n        _.sortedIndex = function (array, obj, iteratee, context) {\n          iteratee = cb(iteratee, context, 1);\n          var value = iteratee(obj);\n          var low = 0,\n              high = getLength(array);\n          while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;\n          }\n          return low;\n        };\n\n        // Generator function to create the indexOf and lastIndexOf functions\n        function createIndexFinder(dir, predicateFind, sortedIndex) {\n          return function (array, item, idx) {\n            var i = 0,\n                length = getLength(array);\n            if (typeof idx == 'number') {\n              if (dir > 0) {\n                i = idx >= 0 ? idx : Math.max(idx + length, i);\n              } else {\n                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n              }\n            } else if (sortedIndex && idx && length) {\n              idx = sortedIndex(array, item);\n              return array[idx] === item ? idx : -1;\n            }\n            if (item !== item) {\n              idx = predicateFind(slice.call(array, i, length), _.isNaN);\n              return idx >= 0 ? idx + i : -1;\n            }\n            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n              if (array[idx] === item) return idx;\n            }\n            return -1;\n          };\n        }\n\n        // Return the position of the first occurrence of an item in an array,\n        // or -1 if the item is not included in the array.\n        // If the array is large and already in sort order, pass `true`\n        // for **isSorted** to use binary search.\n        _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n        _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n        // Generate an integer Array containing an arithmetic progression. A port of\n        // the native Python `range()` function. See\n        // [the Python documentation](http://docs.python.org/library/functions.html#range).\n        _.range = function (start, stop, step) {\n          if (stop == null) {\n            stop = start || 0;\n            start = 0;\n          }\n          step = step || 1;\n\n          var length = Math.max(Math.ceil((stop - start) / step), 0);\n          var range = Array(length);\n\n          for (var idx = 0; idx < length; idx++, start += step) {\n            range[idx] = start;\n          }\n\n          return range;\n        };\n\n        // Function (ahem) Functions\n        // ------------------\n\n        // Determines whether to execute a function as a constructor\n        // or a normal function with the provided arguments\n        var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {\n          if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n          var self = baseCreate(sourceFunc.prototype);\n          var result = sourceFunc.apply(self, args);\n          if (_.isObject(result)) return result;\n          return self;\n        };\n\n        // Create a function bound to a given object (assigning `this`, and arguments,\n        // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n        // available.\n        _.bind = function (func, context) {\n          if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n          if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n          var args = slice.call(arguments, 2);\n          var bound = function bound() {\n            return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n          };\n          return bound;\n        };\n\n        // Partially apply a function by creating a version that has had some of its\n        // arguments pre-filled, without changing its dynamic `this` context. _ acts\n        // as a placeholder, allowing any combination of arguments to be pre-filled.\n        _.partial = function (func) {\n          var boundArgs = slice.call(arguments, 1);\n          var bound = function bound() {\n            var position = 0,\n                length = boundArgs.length;\n            var args = Array(length);\n            for (var i = 0; i < length; i++) {\n              args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n            }\n            while (position < arguments.length) {\n              args.push(arguments[position++]);\n            }return executeBound(func, bound, this, this, args);\n          };\n          return bound;\n        };\n\n        // Bind a number of an object's methods to that object. Remaining arguments\n        // are the method names to be bound. Useful for ensuring that all callbacks\n        // defined on an object belong to it.\n        _.bindAll = function (obj) {\n          var i,\n              length = arguments.length,\n              key;\n          if (length <= 1) throw new Error('bindAll must be passed function names');\n          for (i = 1; i < length; i++) {\n            key = arguments[i];\n            obj[key] = _.bind(obj[key], obj);\n          }\n          return obj;\n        };\n\n        // Memoize an expensive function by storing its results.\n        _.memoize = function (func, hasher) {\n          var memoize = function memoize(key) {\n            var cache = memoize.cache;\n            var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n            if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n            return cache[address];\n          };\n          memoize.cache = {};\n          return memoize;\n        };\n\n        // Delays a function for the given number of milliseconds, and then calls\n        // it with the arguments supplied.\n        _.delay = function (func, wait) {\n          var args = slice.call(arguments, 2);\n          return setTimeout(function () {\n            return func.apply(null, args);\n          }, wait);\n        };\n\n        // Defers a function, scheduling it to run after the current call stack has\n        // cleared.\n        _.defer = _.partial(_.delay, _, 1);\n\n        // Returns a function, that, when invoked, will only be triggered at most once\n        // during a given window of time. Normally, the throttled function will run\n        // as much as it can, without ever going more than once per `wait` duration;\n        // but if you'd like to disable the execution on the leading edge, pass\n        // `{leading: false}`. To disable execution on the trailing edge, ditto.\n        _.throttle = function (func, wait, options) {\n          var context, args, result;\n          var timeout = null;\n          var previous = 0;\n          if (!options) options = {};\n          var later = function later() {\n            previous = options.leading === false ? 0 : _.now();\n            timeout = null;\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          };\n          return function () {\n            var now = _.now();\n            if (!previous && options.leading === false) previous = now;\n            var remaining = wait - (now - previous);\n            context = this;\n            args = arguments;\n            if (remaining <= 0 || remaining > wait) {\n              if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n              }\n              previous = now;\n              result = func.apply(context, args);\n              if (!timeout) context = args = null;\n            } else if (!timeout && options.trailing !== false) {\n              timeout = setTimeout(later, remaining);\n            }\n            return result;\n          };\n        };\n\n        // Returns a function, that, as long as it continues to be invoked, will not\n        // be triggered. The function will be called after it stops being called for\n        // N milliseconds. If `immediate` is passed, trigger the function on the\n        // leading edge, instead of the trailing.\n        _.debounce = function (func, wait, immediate) {\n          var timeout, args, context, timestamp, result;\n\n          var later = function later() {\n            var last = _.now() - timestamp;\n\n            if (last < wait && last >= 0) {\n              timeout = setTimeout(later, wait - last);\n            } else {\n              timeout = null;\n              if (!immediate) {\n                result = func.apply(context, args);\n                if (!timeout) context = args = null;\n              }\n            }\n          };\n\n          return function () {\n            context = this;\n            args = arguments;\n            timestamp = _.now();\n            var callNow = immediate && !timeout;\n            if (!timeout) timeout = setTimeout(later, wait);\n            if (callNow) {\n              result = func.apply(context, args);\n              context = args = null;\n            }\n\n            return result;\n          };\n        };\n\n        // Returns the first function passed as an argument to the second,\n        // allowing you to adjust arguments, run code before and after, and\n        // conditionally execute the original function.\n        _.wrap = function (func, wrapper) {\n          return _.partial(wrapper, func);\n        };\n\n        // Returns a negated version of the passed-in predicate.\n        _.negate = function (predicate) {\n          return function () {\n            return !predicate.apply(this, arguments);\n          };\n        };\n\n        // Returns a function that is the composition of a list of functions, each\n        // consuming the return value of the function that follows.\n        _.compose = function () {\n          var args = arguments;\n          var start = args.length - 1;\n          return function () {\n            var i = start;\n            var result = args[start].apply(this, arguments);\n            while (i--) {\n              result = args[i].call(this, result);\n            }return result;\n          };\n        };\n\n        // Returns a function that will only be executed on and after the Nth call.\n        _.after = function (times, func) {\n          return function () {\n            if (--times < 1) {\n              return func.apply(this, arguments);\n            }\n          };\n        };\n\n        // Returns a function that will only be executed up to (but not including) the Nth call.\n        _.before = function (times, func) {\n          var memo;\n          return function () {\n            if (--times > 0) {\n              memo = func.apply(this, arguments);\n            }\n            if (times <= 1) func = null;\n            return memo;\n          };\n        };\n\n        // Returns a function that will be executed at most one time, no matter how\n        // often you call it. Useful for lazy initialization.\n        _.once = _.partial(_.before, 2);\n\n        // Object Functions\n        // ----------------\n\n        // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n        var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n        function collectNonEnumProps(obj, keys) {\n          var nonEnumIdx = nonEnumerableProps.length;\n          var constructor = obj.constructor;\n          var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n          // Constructor is a special case.\n          var prop = 'constructor';\n          if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n          while (nonEnumIdx--) {\n            prop = nonEnumerableProps[nonEnumIdx];\n            if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n              keys.push(prop);\n            }\n          }\n        }\n\n        // Retrieve the names of an object's own properties.\n        // Delegates to **ECMAScript 5**'s native `Object.keys`\n        _.keys = function (obj) {\n          if (!_.isObject(obj)) return [];\n          if (nativeKeys) return nativeKeys(obj);\n          var keys = [];\n          for (var key in obj) {\n            if (_.has(obj, key)) keys.push(key);\n          } // Ahem, IE < 9.\n          if (hasEnumBug) collectNonEnumProps(obj, keys);\n          return keys;\n        };\n\n        // Retrieve all the property names of an object.\n        _.allKeys = function (obj) {\n          if (!_.isObject(obj)) return [];\n          var keys = [];\n          for (var key in obj) {\n            keys.push(key);\n          } // Ahem, IE < 9.\n          if (hasEnumBug) collectNonEnumProps(obj, keys);\n          return keys;\n        };\n\n        // Retrieve the values of an object's properties.\n        _.values = function (obj) {\n          var keys = _.keys(obj);\n          var length = keys.length;\n          var values = Array(length);\n          for (var i = 0; i < length; i++) {\n            values[i] = obj[keys[i]];\n          }\n          return values;\n        };\n\n        // Returns the results of applying the iteratee to each element of the object\n        // In contrast to _.map it returns an object\n        _.mapObject = function (obj, iteratee, context) {\n          iteratee = cb(iteratee, context);\n          var keys = _.keys(obj),\n              length = keys.length,\n              results = {},\n              currentKey;\n          for (var index = 0; index < length; index++) {\n            currentKey = keys[index];\n            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n          }\n          return results;\n        };\n\n        // Convert an object into a list of `[key, value]` pairs.\n        _.pairs = function (obj) {\n          var keys = _.keys(obj);\n          var length = keys.length;\n          var pairs = Array(length);\n          for (var i = 0; i < length; i++) {\n            pairs[i] = [keys[i], obj[keys[i]]];\n          }\n          return pairs;\n        };\n\n        // Invert the keys and values of an object. The values must be serializable.\n        _.invert = function (obj) {\n          var result = {};\n          var keys = _.keys(obj);\n          for (var i = 0, length = keys.length; i < length; i++) {\n            result[obj[keys[i]]] = keys[i];\n          }\n          return result;\n        };\n\n        // Return a sorted list of the function names available on the object.\n        // Aliased as `methods`\n        _.functions = _.methods = function (obj) {\n          var names = [];\n          for (var key in obj) {\n            if (_.isFunction(obj[key])) names.push(key);\n          }\n          return names.sort();\n        };\n\n        // Extend a given object with all the properties in passed-in object(s).\n        _.extend = createAssigner(_.allKeys);\n\n        // Assigns a given object with all the own properties in the passed-in object(s)\n        // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n        _.extendOwn = _.assign = createAssigner(_.keys);\n\n        // Returns the first key on an object that passes a predicate test\n        _.findKey = function (obj, predicate, context) {\n          predicate = cb(predicate, context);\n          var keys = _.keys(obj),\n              key;\n          for (var i = 0, length = keys.length; i < length; i++) {\n            key = keys[i];\n            if (predicate(obj[key], key, obj)) return key;\n          }\n        };\n\n        // Return a copy of the object only containing the whitelisted properties.\n        _.pick = function (object, oiteratee, context) {\n          var result = {},\n              obj = object,\n              iteratee,\n              keys;\n          if (obj == null) return result;\n          if (_.isFunction(oiteratee)) {\n            keys = _.allKeys(obj);\n            iteratee = optimizeCb(oiteratee, context);\n          } else {\n            keys = flatten(arguments, false, false, 1);\n            iteratee = function iteratee(value, key, obj) {\n              return key in obj;\n            };\n            obj = Object(obj);\n          }\n          for (var i = 0, length = keys.length; i < length; i++) {\n            var key = keys[i];\n            var value = obj[key];\n            if (iteratee(value, key, obj)) result[key] = value;\n          }\n          return result;\n        };\n\n        // Return a copy of the object without the blacklisted properties.\n        _.omit = function (obj, iteratee, context) {\n          if (_.isFunction(iteratee)) {\n            iteratee = _.negate(iteratee);\n          } else {\n            var keys = _.map(flatten(arguments, false, false, 1), String);\n            iteratee = function iteratee(value, key) {\n              return !_.contains(keys, key);\n            };\n          }\n          return _.pick(obj, iteratee, context);\n        };\n\n        // Fill in a given object with default properties.\n        _.defaults = createAssigner(_.allKeys, true);\n\n        // Creates an object that inherits from the given prototype object.\n        // If additional properties are provided then they will be added to the\n        // created object.\n        _.create = function (prototype, props) {\n          var result = baseCreate(prototype);\n          if (props) _.extendOwn(result, props);\n          return result;\n        };\n\n        // Create a (shallow-cloned) duplicate of an object.\n        _.clone = function (obj) {\n          if (!_.isObject(obj)) return obj;\n          return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n        };\n\n        // Invokes interceptor with the obj, and then returns obj.\n        // The primary purpose of this method is to \"tap into\" a method chain, in\n        // order to perform operations on intermediate results within the chain.\n        _.tap = function (obj, interceptor) {\n          interceptor(obj);\n          return obj;\n        };\n\n        // Returns whether an object has a given set of `key:value` pairs.\n        _.isMatch = function (object, attrs) {\n          var keys = _.keys(attrs),\n              length = keys.length;\n          if (object == null) return !length;\n          var obj = Object(object);\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            if (attrs[key] !== obj[key] || !(key in obj)) return false;\n          }\n          return true;\n        };\n\n        // Internal recursive comparison function for `isEqual`.\n        var eq = function eq(a, b, aStack, bStack) {\n          // Identical objects are equal. `0 === -0`, but they aren't identical.\n          // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n          if (a === b) return a !== 0 || 1 / a === 1 / b;\n          // A strict comparison is necessary because `null == undefined`.\n          if (a == null || b == null) return a === b;\n          // Unwrap any wrapped objects.\n          if (a instanceof _) a = a._wrapped;\n          if (b instanceof _) b = b._wrapped;\n          // Compare `[[Class]]` names.\n          var className = toString.call(a);\n          if (className !== toString.call(b)) return false;\n          switch (className) {\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n            case '[object RegExp]':\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n            case '[object String]':\n              // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n              // equivalent to `new String(\"5\")`.\n              return '' + a === '' + b;\n            case '[object Number]':\n              // `NaN`s are equivalent, but non-reflexive.\n              // Object(NaN) is equivalent to NaN\n              if (+a !== +a) return +b !== +b;\n              // An `egal` comparison is performed for other numeric values.\n              return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n            case '[object Date]':\n            case '[object Boolean]':\n              // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n              // millisecond representations. Note that invalid dates with millisecond representations\n              // of `NaN` are not equivalent.\n              return +a === +b;\n          }\n\n          var areArrays = className === '[object Array]';\n          if (!areArrays) {\n            if ((typeof a === 'undefined' ? 'undefined' : _typeof2(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof2(b)) != 'object') return false;\n\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n            // from different frames are.\n            var aCtor = a.constructor,\n                bCtor = b.constructor;\n            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {\n              return false;\n            }\n          }\n          // Assume equality for cyclic structures. The algorithm for detecting cyclic\n          // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n          // Initializing stack of traversed objects.\n          // It's done here since we only need them for objects and arrays comparison.\n          aStack = aStack || [];\n          bStack = bStack || [];\n          var length = aStack.length;\n          while (length--) {\n            // Linear search. Performance is inversely proportional to the number of\n            // unique nested structures.\n            if (aStack[length] === a) return bStack[length] === b;\n          }\n\n          // Add the first object to the stack of traversed objects.\n          aStack.push(a);\n          bStack.push(b);\n\n          // Recursively compare objects and arrays.\n          if (areArrays) {\n            // Compare array lengths to determine if a deep comparison is necessary.\n            length = a.length;\n            if (length !== b.length) return false;\n            // Deep compare the contents, ignoring non-numeric properties.\n            while (length--) {\n              if (!eq(a[length], b[length], aStack, bStack)) return false;\n            }\n          } else {\n            // Deep compare objects.\n            var keys = _.keys(a),\n                key;\n            length = keys.length;\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\n            if (_.keys(b).length !== length) return false;\n            while (length--) {\n              // Deep compare each member\n              key = keys[length];\n              if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n            }\n          }\n          // Remove the first object from the stack of traversed objects.\n          aStack.pop();\n          bStack.pop();\n          return true;\n        };\n\n        // Perform a deep comparison to check if two objects are equal.\n        _.isEqual = function (a, b) {\n          return eq(a, b);\n        };\n\n        // Is a given array, string, or object empty?\n        // An \"empty\" object has no enumerable own-properties.\n        _.isEmpty = function (obj) {\n          if (obj == null) return true;\n          if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n          return _.keys(obj).length === 0;\n        };\n\n        // Is a given value a DOM element?\n        _.isElement = function (obj) {\n          return !!(obj && obj.nodeType === 1);\n        };\n\n        // Is a given value an array?\n        // Delegates to ECMA5's native Array.isArray\n        _.isArray = nativeIsArray || function (obj) {\n          return toString.call(obj) === '[object Array]';\n        };\n\n        // Is a given variable an object?\n        _.isObject = function (obj) {\n          var type = typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n          return type === 'function' || type === 'object' && !!obj;\n        };\n\n        // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n        _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) {\n          _['is' + name] = function (obj) {\n            return toString.call(obj) === '[object ' + name + ']';\n          };\n        });\n\n        // Define a fallback version of the method in browsers (ahem, IE < 9), where\n        // there isn't any inspectable \"Arguments\" type.\n        if (!_.isArguments(arguments)) {\n          _.isArguments = function (obj) {\n            return _.has(obj, 'callee');\n          };\n        }\n\n        // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n        // IE 11 (#1621), and in Safari 8 (#1929).\n        if (typeof /./ != 'function' && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof2(Int8Array)) != 'object') {\n          _.isFunction = function (obj) {\n            return typeof obj == 'function' || false;\n          };\n        }\n\n        // Is a given object a finite number?\n        _.isFinite = function (obj) {\n          return isFinite(obj) && !isNaN(parseFloat(obj));\n        };\n\n        // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n        _.isNaN = function (obj) {\n          return _.isNumber(obj) && obj !== +obj;\n        };\n\n        // Is a given value a boolean?\n        _.isBoolean = function (obj) {\n          return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n        };\n\n        // Is a given value equal to null?\n        _.isNull = function (obj) {\n          return obj === null;\n        };\n\n        // Is a given variable undefined?\n        _.isUndefined = function (obj) {\n          return obj === void 0;\n        };\n\n        // Shortcut function for checking if an object has a given property directly\n        // on itself (in other words, not on a prototype).\n        _.has = function (obj, key) {\n          return obj != null && hasOwnProperty.call(obj, key);\n        };\n\n        // Utility Functions\n        // -----------------\n\n        // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n        // previous owner. Returns a reference to the Underscore object.\n        _.noConflict = function () {\n          root._ = previousUnderscore;\n          return this;\n        };\n\n        // Keep the identity function around for default iteratees.\n        _.identity = function (value) {\n          return value;\n        };\n\n        // Predicate-generating functions. Often useful outside of Underscore.\n        _.constant = function (value) {\n          return function () {\n            return value;\n          };\n        };\n\n        _.noop = function () {};\n\n        _.property = property;\n\n        // Generates a function for a given object that returns a given property.\n        _.propertyOf = function (obj) {\n          return obj == null ? function () {} : function (key) {\n            return obj[key];\n          };\n        };\n\n        // Returns a predicate for checking whether an object has a given set of\n        // `key:value` pairs.\n        _.matcher = _.matches = function (attrs) {\n          attrs = _.extendOwn({}, attrs);\n          return function (obj) {\n            return _.isMatch(obj, attrs);\n          };\n        };\n\n        // Run a function **n** times.\n        _.times = function (n, iteratee, context) {\n          var accum = Array(Math.max(0, n));\n          iteratee = optimizeCb(iteratee, context, 1);\n          for (var i = 0; i < n; i++) {\n            accum[i] = iteratee(i);\n          }return accum;\n        };\n\n        // Return a random integer between min and max (inclusive).\n        _.random = function (min, max) {\n          if (max == null) {\n            max = min;\n            min = 0;\n          }\n          return min + Math.floor(Math.random() * (max - min + 1));\n        };\n\n        // A (possibly faster) way to get the current timestamp as an integer.\n        _.now = Date.now || function () {\n          return new Date().getTime();\n        };\n\n        // List of HTML entities for escaping.\n        var escapeMap = {\n          '&': '&amp;',\n          '<': '&lt;',\n          '>': '&gt;',\n          '\"': '&quot;',\n          \"'\": '&#x27;',\n          '`': '&#x60;'\n        };\n        var unescapeMap = _.invert(escapeMap);\n\n        // Functions for escaping and unescaping strings to/from HTML interpolation.\n        var createEscaper = function createEscaper(map) {\n          var escaper = function escaper(match) {\n            return map[match];\n          };\n          // Regexes for identifying a key that needs to be escaped\n          var source = '(?:' + _.keys(map).join('|') + ')';\n          var testRegexp = RegExp(source);\n          var replaceRegexp = RegExp(source, 'g');\n          return function (string) {\n            string = string == null ? '' : '' + string;\n            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n          };\n        };\n        _.escape = createEscaper(escapeMap);\n        _.unescape = createEscaper(unescapeMap);\n\n        // If the value of the named `property` is a function then invoke it with the\n        // `object` as context; otherwise, return it.\n        _.result = function (object, property, fallback) {\n          var value = object == null ? void 0 : object[property];\n          if (value === void 0) {\n            value = fallback;\n          }\n          return _.isFunction(value) ? value.call(object) : value;\n        };\n\n        // Generate a unique integer id (unique within the entire client session).\n        // Useful for temporary DOM ids.\n        var idCounter = 0;\n        _.uniqueId = function (prefix) {\n          var id = ++idCounter + '';\n          return prefix ? prefix + id : id;\n        };\n\n        // By default, Underscore uses ERB-style template delimiters, change the\n        // following template settings to use alternative delimiters.\n        _.templateSettings = {\n          evaluate: /<%([\\s\\S]+?)%>/g,\n          interpolate: /<%=([\\s\\S]+?)%>/g,\n          escape: /<%-([\\s\\S]+?)%>/g\n        };\n\n        // When customizing `templateSettings`, if you don't want to define an\n        // interpolation, evaluation or escaping regex, we need one that is\n        // guaranteed not to match.\n        var noMatch = /(.)^/;\n\n        // Certain characters need to be escaped so that they can be put into a\n        // string literal.\n        var escapes = {\n          \"'\": \"'\",\n          '\\\\': '\\\\',\n          '\\r': 'r',\n          '\\n': 'n',\n          '\\u2028': 'u2028',\n          '\\u2029': 'u2029'\n        };\n\n        var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n        var escapeChar = function escapeChar(match) {\n          return '\\\\' + escapes[match];\n        };\n\n        // JavaScript micro-templating, similar to John Resig's implementation.\n        // Underscore templating handles arbitrary delimiters, preserves whitespace,\n        // and correctly escapes quotes within interpolated code.\n        // NB: `oldSettings` only exists for backwards compatibility.\n        _.template = function (text, settings, oldSettings) {\n          if (!settings && oldSettings) settings = oldSettings;\n          settings = _.defaults({}, settings, _.templateSettings);\n\n          // Combine delimiters into one regular expression via alternation.\n          var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');\n\n          // Compile the template source, escaping string literals appropriately.\n          var index = 0;\n          var source = \"__p+='\";\n          text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n            source += text.slice(index, offset).replace(escaper, escapeChar);\n            index = offset + match.length;\n\n            if (escape) {\n              source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n            } else if (interpolate) {\n              source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n            } else if (evaluate) {\n              source += \"';\\n\" + evaluate + \"\\n__p+='\";\n            }\n\n            // Adobe VMs need the match returned to produce the correct offest.\n            return match;\n          });\n          source += \"';\\n\";\n\n          // If a variable is not specified, place data values in local scope.\n          if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n          source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + source + 'return __p;\\n';\n\n          try {\n            var render = new Function(settings.variable || 'obj', '_', source);\n          } catch (e) {\n            e.source = source;\n            throw e;\n          }\n\n          var template = function template(data) {\n            return render.call(this, data, _);\n          };\n\n          // Provide the compiled source as a convenience for precompilation.\n          var argument = settings.variable || 'obj';\n          template.source = 'function(' + argument + '){\\n' + source + '}';\n\n          return template;\n        };\n\n        // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n        _.chain = function (obj) {\n          var instance = _(obj);\n          instance._chain = true;\n          return instance;\n        };\n\n        // OOP\n        // ---------------\n        // If Underscore is called as a function, it returns a wrapped object that\n        // can be used OO-style. This wrapper holds altered versions of all the\n        // underscore functions. Wrapped objects may be chained.\n\n        // Helper function to continue chaining intermediate results.\n        var result = function result(instance, obj) {\n          return instance._chain ? _(obj).chain() : obj;\n        };\n\n        // Add your own custom functions to the Underscore object.\n        _.mixin = function (obj) {\n          _.each(_.functions(obj), function (name) {\n            var func = _[name] = obj[name];\n            _.prototype[name] = function () {\n              var args = [this._wrapped];\n              push.apply(args, arguments);\n              return result(this, func.apply(_, args));\n            };\n          });\n        };\n\n        // Add all of the Underscore functions to the wrapper object.\n        _.mixin(_);\n\n        // Add all mutator Array functions to the wrapper.\n        _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n          var method = ArrayProto[name];\n          _.prototype[name] = function () {\n            var obj = this._wrapped;\n            method.apply(obj, arguments);\n            if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n            return result(this, obj);\n          };\n        });\n\n        // Add all accessor Array functions to the wrapper.\n        _.each(['concat', 'join', 'slice'], function (name) {\n          var method = ArrayProto[name];\n          _.prototype[name] = function () {\n            return result(this, method.apply(this._wrapped, arguments));\n          };\n        });\n\n        // Extracts the result from a wrapped and chained object.\n        _.prototype.value = function () {\n          return this._wrapped;\n        };\n\n        // Provide unwrapping proxy for some methods used in engine operations\n        // such as arithmetic and JSON stringification.\n        _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n        _.prototype.toString = function () {\n          return '' + this._wrapped;\n        };\n\n        // AMD registration happens at the end for compatibility with AMD loaders\n        // that may not enforce next-turn semantics on modules. Even though general\n        // practice for AMD registration is to be anonymous, underscore registers\n        // as a named module because, like jQuery, it is a base library that is\n        // popular enough to be bundled in a third party lib, but not be part of\n        // an AMD load request. Those cases could generate an error when an\n        // anonymous define() is called outside of a loader request.\n        if (true) {\n          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return _;\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        }\n      }).call(this);\n\n      /***/\n    },\n    /* 11 */\n    /***/function (module, exports, __webpack_require__) {\n\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n        };\n      }();\n\n      var _index = __webpack_require__(7);\n\n      var _index2 = _interopRequireDefault(_index);\n\n      var _index3 = __webpack_require__(3);\n\n      var _index4 = _interopRequireDefault(_index3);\n\n      var _underscore = __webpack_require__(10);\n\n      var _underscore2 = _interopRequireDefault(_underscore);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : { default: obj };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      /**\n       * 弹框，默认alert类型\n       */\n\n      function noop() {}\n\n      var defalutOption = {\n        title: \"温馨提示\",\n        msg: \"\",\n        okText: \"确定\",\n        cancelText: \"取消\",\n        callback: noop,\n        autoHide: true,\n        type: \"alert\",\n        html: ''\n      };\n\n      var ALERT_TYPE = {\n        alert: \"alert\",\n        confirm: \"confirm\",\n        warning: 'warning'\n      };\n\n      function defaults(opt, defaults) {\n        if (opt.html) {\n          opt.msg = '';\n        }\n        if (opt.type == 'warning' && opt.title == undefined) {\n          opt.title = '';\n        }\n        for (var key in defaults) {\n          if (opt[key] == void 0) {\n            opt[key] = defaults[key];\n          }\n        }\n        return opt;\n      }\n\n      var Alert = function () {\n        function Alert(opt) {\n          _classCallCheck(this, Alert);\n\n          this.alertBox = null;\n          this.option = defaults(opt, defalutOption);\n          this.option.showCancel = this.option.type == ALERT_TYPE.confirm;\n\n          this.option.titleALL = _underscore2.default.isArray(this.option.title) ? this.option.title : [this.option.title];\n          if (this.option.html !== '') {\n            this.option.appendHtml = this.option.html;\n          } else {\n            this.option.appendHtml = false;\n          }\n\n          this.option.tips = _underscore2.default.isArray(this.option.msg) ? this.option.msg : [this.option.msg];\n          this.option.contentClassName = this.option.tips.length <= 1 ? \"custom-tip-single\" : \"\";\n          this.option.isHide = this.option.msg === '' ? \"fn-hide\" : '';\n\n          if (this.option.titleALL.length === 1 && this.option.msg === '' && this.option.html === '') {\n            this.option.titleClassName = \"title-online\";\n          } else if (this.option.titleALL.length > 1) {\n            this.option.titleClassName = \"title-padding-two\";\n          }\n\n          this.show(this.option);\n        }\n\n        /**\n         * 显示\n         * @param opt\n         */\n\n        _createClass(Alert, [{\n          key: 'show',\n          value: function show(opt) {\n            this.alertBox = $((0, _index2.default)(opt));\n            $(\"body\").append(this.alertBox);\n            this.bindEvent(opt);\n          }\n\n          /**\n           * 隐藏\n           */\n\n        }, {\n          key: 'hide',\n          value: function hide() {\n            var _this = this;\n\n            var $content = this.alertBox.find('.custom-alert');\n            $content.removeClass('in').addClass('out');\n            $content.one('transitionend webkitTransitionEnd animationend webkitAnimationend', function () {\n              $content.removeClass('out');\n              $content.unbind('transitionend').unbind('webkitTransitionEnd').unbind('animationend').unbind('webkitAnimationend');\n              _this.alertBox.remove();\n            });\n          }\n        }, {\n          key: 'bindEvent',\n          value: function bindEvent(data) {\n            var self = this;\n            this.alertBox.find(\".custom-alert-ok\").on(\"click\", function () {\n              if (self.option.autoHide) {\n                self.hide();\n              }\n              data.callback(true);\n            });\n\n            if (self.option.type === ALERT_TYPE.confirm) {\n              this.alertBox.find(\".custom-alert-cancel\").on(\"click\", function () {\n                if (self.option.autoHide) {\n                  self.hide();\n                }\n                data.callback(false);\n              });\n            }\n          }\n        }]);\n\n        return Alert;\n      }();\n\n      function CustomAlert() {\n        for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n          options[_key] = arguments[_key];\n        }\n\n        var option = options;\n        if (typeof options[0] === \"string\") {\n          var type = options[1] === 'confirm' ? 'confirm' : 'alert';\n          option = {\n            type: type,\n            title: options[0],\n            callback: function callback(result) {\n              console.log('\\u4F60\\u70B9\\u51FB\\u4E86' + result);\n            }\n          };\n        } else if (_typeof(options[0]) === \"object\") {\n          option = options[0];\n        }\n        return new Alert(option);\n      }\n\n      exports.default = CustomAlert;\n\n      /***/\n    }]\n    /******/)\n  );\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3p6YzIwMTYxMTAxL0Rlc2t0b3AvZ2l0L3BlcnNvbmFsL3VpLWNvbXBvbmVudHMvZGlzdC9hbGVydC9pbmRleC5qcz82YTFkIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiYSIsImkiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImwiLCJjYWxsIiwibSIsImMiLCJ2YWx1ZSIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJkZWZpbmUiLCJhbWQiLCJpZCIsImxvYWRlZCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9oYW5kbGViYXJzQmFzZSIsImJhc2UiLCJfaGFuZGxlYmFyc1NhZmVTdHJpbmciLCJfaGFuZGxlYmFyc1NhZmVTdHJpbmcyIiwiX2hhbmRsZWJhcnNFeGNlcHRpb24iLCJfaGFuZGxlYmFyc0V4Y2VwdGlvbjIiLCJfaGFuZGxlYmFyc1V0aWxzIiwiVXRpbHMiLCJfaGFuZGxlYmFyc1J1bnRpbWUiLCJydW50aW1lIiwiX2hhbmRsZWJhcnNOb0NvbmZsaWN0IiwiX2hhbmRsZWJhcnNOb0NvbmZsaWN0MiIsImNyZWF0ZSIsImhiIiwiSGFuZGxlYmFyc0Vudmlyb25tZW50IiwiZXh0ZW5kIiwiU2FmZVN0cmluZyIsIkV4Y2VwdGlvbiIsImVzY2FwZUV4cHJlc3Npb24iLCJWTSIsInRlbXBsYXRlIiwic3BlYyIsImluc3QiLCJvYmoiLCJuZXdPYmoiLCJrZXkiLCJfdXRpbHMiLCJfZXhjZXB0aW9uIiwiX2V4Y2VwdGlvbjIiLCJfaGVscGVycyIsIl9kZWNvcmF0b3JzIiwiX2xvZ2dlciIsIl9sb2dnZXIyIiwiVkVSU0lPTiIsIkNPTVBJTEVSX1JFVklTSU9OIiwiUkVWSVNJT05fQ0hBTkdFUyIsIm9iamVjdFR5cGUiLCJoZWxwZXJzIiwicGFydGlhbHMiLCJkZWNvcmF0b3JzIiwicmVnaXN0ZXJEZWZhdWx0SGVscGVycyIsInJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMiLCJjb25zdHJ1Y3RvciIsImxvZ2dlciIsImxvZyIsInJlZ2lzdGVySGVscGVyIiwiZm4iLCJ0b1N0cmluZyIsInVucmVnaXN0ZXJIZWxwZXIiLCJyZWdpc3RlclBhcnRpYWwiLCJwYXJ0aWFsIiwidW5yZWdpc3RlclBhcnRpYWwiLCJyZWdpc3RlckRlY29yYXRvciIsInVucmVnaXN0ZXJEZWNvcmF0b3IiLCJjcmVhdGVGcmFtZSIsImluZGV4T2YiLCJpc0VtcHR5IiwiYmxvY2tQYXJhbXMiLCJhcHBlbmRDb250ZXh0UGF0aCIsImVzY2FwZSIsImJhZENoYXJzIiwicG9zc2libGUiLCJlc2NhcGVDaGFyIiwiY2hyIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaXNGdW5jdGlvbiIsImlzQXJyYXkiLCJBcnJheSIsImFycmF5IiwibGVuIiwic3RyaW5nIiwidG9IVE1MIiwidGVzdCIsInJlcGxhY2UiLCJmcmFtZSIsIl9wYXJlbnQiLCJwYXJhbXMiLCJpZHMiLCJwYXRoIiwiY29udGV4dFBhdGgiLCJfT2JqZWN0JGRlZmluZVByb3BlcnR5IiwiZXJyb3JQcm9wcyIsIm1lc3NhZ2UiLCJub2RlIiwibG9jIiwibGluZSIsInVuZGVmaW5lZCIsImNvbHVtbiIsInN0YXJ0IiwidG1wIiwiRXJyb3IiLCJpZHgiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImxpbmVOdW1iZXIiLCJub3AiLCIkIiwiaXQiLCJkZXNjIiwic2V0RGVzYyIsIiRPYmplY3QiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiaXNFbnVtIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXREZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic2V0RGVzY3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0S2V5cyIsImtleXMiLCJnZXROYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZWFjaCIsImZvckVhY2giLCJfaGVscGVyc0Jsb2NrSGVscGVyTWlzc2luZyIsIl9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nMiIsIl9oZWxwZXJzRWFjaCIsIl9oZWxwZXJzRWFjaDIiLCJfaGVscGVyc0hlbHBlck1pc3NpbmciLCJfaGVscGVyc0hlbHBlck1pc3NpbmcyIiwiX2hlbHBlcnNJZiIsIl9oZWxwZXJzSWYyIiwiX2hlbHBlcnNMb2ciLCJfaGVscGVyc0xvZzIiLCJfaGVscGVyc0xvb2t1cCIsIl9oZWxwZXJzTG9va3VwMiIsIl9oZWxwZXJzV2l0aCIsIl9oZWxwZXJzV2l0aDIiLCJpbnN0YW5jZSIsImNvbnRleHQiLCJvcHRpb25zIiwiaW52ZXJzZSIsImRhdGEiLCJyZXQiLCJleGVjSXRlcmF0aW9uIiwiZmllbGQiLCJpbmRleCIsImxhc3QiLCJmaXJzdCIsImoiLCJwcmlvcktleSIsImNvbmRpdGlvbmFsIiwiaGFzaCIsImluY2x1ZGVaZXJvIiwiYXJncyIsInB1c2giLCJsZXZlbCIsImFwcGx5IiwiX2RlY29yYXRvcnNJbmxpbmUiLCJfZGVjb3JhdG9yc0lubGluZTIiLCJwcm9wcyIsImNvbnRhaW5lciIsIm9yaWdpbmFsIiwibWV0aG9kTWFwIiwibG9va3VwTGV2ZWwiLCJsZXZlbE1hcCIsInRvTG93ZXJDYXNlIiwicGFyc2VJbnQiLCJjb25zb2xlIiwibWV0aG9kIiwiX2xlbiIsIl9rZXkiLCJfT2JqZWN0JHNlYWwiLCJjaGVja1JldmlzaW9uIiwid3JhcFByb2dyYW0iLCJyZXNvbHZlUGFydGlhbCIsImludm9rZVBhcnRpYWwiLCJub29wIiwiX2Jhc2UiLCJjb21waWxlckluZm8iLCJjb21waWxlclJldmlzaW9uIiwiY3VycmVudFJldmlzaW9uIiwicnVudGltZVZlcnNpb25zIiwiY29tcGlsZXJWZXJzaW9ucyIsInRlbXBsYXRlU3BlYyIsImVudiIsIm1haW4iLCJkZWNvcmF0b3IiLCJtYWluX2QiLCJjb21waWxlciIsImludm9rZVBhcnRpYWxXcmFwcGVyIiwicmVzdWx0IiwiY29tcGlsZSIsImNvbXBpbGVyT3B0aW9ucyIsImluZGVudCIsImxpbmVzIiwic3BsaXQiLCJqb2luIiwic3RyaWN0IiwibG9va3VwIiwiZGVwdGhzIiwibGFtYmRhIiwiY3VycmVudCIsInByb2dyYW1zIiwicHJvZ3JhbSIsImRlY2xhcmVkQmxvY2tQYXJhbXMiLCJwcm9ncmFtV3JhcHBlciIsImRlcHRoIiwibWVyZ2UiLCJwYXJhbSIsImNvbW1vbiIsIm51bGxDb250ZXh0IiwiX3NldHVwIiwidXNlRGF0YSIsImluaXREYXRhIiwidXNlQmxvY2tQYXJhbXMiLCJ1c2VEZXB0aHMiLCJjb25jYXQiLCJleGVjdXRlRGVjb3JhdG9ycyIsImlzVG9wIiwidXNlUGFydGlhbCIsInVzZURlY29yYXRvcnMiLCJfY2hpbGQiLCJwcm9nIiwiY3VycmVudERlcHRocyIsImN1cnJlbnRQYXJ0aWFsQmxvY2siLCJwYXJ0aWFsQmxvY2siLCJwYXJ0aWFsQmxvY2tXcmFwcGVyIiwiRnVuY3Rpb24iLCJzZWFsIiwiaXNPYmplY3QiLCIkc2VhbCIsIiRleHBvcnQiLCJjb3JlIiwiZmFpbHMiLCJLRVkiLCJleGVjIiwiZXhwIiwiUyIsIkYiLCJnbG9iYWwiLCJjdHgiLCJQUk9UT1RZUEUiLCJ0eXBlIiwic291cmNlIiwiSVNfRk9SQ0VEIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiUCIsIklTX0JJTkQiLCJCIiwiSVNfV1JBUCIsIlciLCJ0YXJnZXQiLCJvd24iLCJvdXQiLCJDIiwid2luZG93IiwiTWF0aCIsInNlbGYiLCJfX2ciLCJ2ZXJzaW9uIiwiX19lIiwiYUZ1bmN0aW9uIiwidGhhdCIsImIiLCJUeXBlRXJyb3IiLCJlIiwiSGFuZGxlYmFycyIsIiRIYW5kbGViYXJzIiwibm9Db25mbGljdCIsIl9fZGVmYXVsdCIsImRlcHRoMCIsImFsaWFzMSIsImFsaWFzMiIsImlzSGlkZSIsInN0YWNrMSIsImhlbHBlciIsImFwcGVuZEh0bWwiLCJoZWxwZXJNaXNzaW5nIiwiY2FuY2VsVGV4dCIsImFsaWFzMyIsImFsaWFzNCIsInRpdGxlQ2xhc3NOYW1lIiwiY29udGVudENsYXNzTmFtZSIsInRpdGxlQUxMIiwidGlwcyIsInNob3dDYW5jZWwiLCJva1RleHQiLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18iLCJwcmV2aW91c1VuZGVyc2NvcmUiLCJfIiwiQXJyYXlQcm90byIsIk9ialByb3RvIiwiRnVuY1Byb3RvIiwic2xpY2UiLCJuYXRpdmVJc0FycmF5IiwibmF0aXZlS2V5cyIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwibmF0aXZlQ3JlYXRlIiwiQ3RvciIsIl93cmFwcGVkIiwib3B0aW1pemVDYiIsImZ1bmMiLCJhcmdDb3VudCIsIm90aGVyIiwiY29sbGVjdGlvbiIsImFjY3VtdWxhdG9yIiwiY2IiLCJpZGVudGl0eSIsIm1hdGNoZXIiLCJpdGVyYXRlZSIsIkluZmluaXR5IiwiY3JlYXRlQXNzaWduZXIiLCJrZXlzRnVuYyIsInVuZGVmaW5lZE9ubHkiLCJiYXNlQ3JlYXRlIiwiTUFYX0FSUkFZX0lOREVYIiwicG93IiwiZ2V0TGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJtYXAiLCJjb2xsZWN0IiwicmVzdWx0cyIsImN1cnJlbnRLZXkiLCJjcmVhdGVSZWR1Y2UiLCJkaXIiLCJpdGVyYXRvciIsIm1lbW8iLCJyZWR1Y2UiLCJmb2xkbCIsImluamVjdCIsInJlZHVjZVJpZ2h0IiwiZm9sZHIiLCJmaW5kIiwiZGV0ZWN0IiwicHJlZGljYXRlIiwiZmluZEluZGV4IiwiZmluZEtleSIsImZpbHRlciIsInNlbGVjdCIsImxpc3QiLCJyZWplY3QiLCJuZWdhdGUiLCJldmVyeSIsImFsbCIsInNvbWUiLCJhbnkiLCJjb250YWlucyIsImluY2x1ZGVzIiwiaW5jbHVkZSIsIml0ZW0iLCJmcm9tSW5kZXgiLCJndWFyZCIsInZhbHVlcyIsImludm9rZSIsImlzRnVuYyIsInBsdWNrIiwid2hlcmUiLCJhdHRycyIsImZpbmRXaGVyZSIsIm1heCIsImxhc3RDb21wdXRlZCIsImNvbXB1dGVkIiwibWluIiwic2h1ZmZsZSIsInNldCIsInNodWZmbGVkIiwicmFuZCIsInJhbmRvbSIsInNhbXBsZSIsInNvcnRCeSIsImNyaXRlcmlhIiwic29ydCIsImxlZnQiLCJyaWdodCIsImdyb3VwIiwiYmVoYXZpb3IiLCJncm91cEJ5IiwiaGFzIiwiaW5kZXhCeSIsImNvdW50QnkiLCJ0b0FycmF5Iiwic2l6ZSIsInBhcnRpdGlvbiIsInBhc3MiLCJmYWlsIiwiaGVhZCIsInRha2UiLCJpbml0aWFsIiwicmVzdCIsInRhaWwiLCJkcm9wIiwiY29tcGFjdCIsImZsYXR0ZW4iLCJpbnB1dCIsInNoYWxsb3ciLCJzdGFydEluZGV4Iiwib3V0cHV0IiwiaXNBcmd1bWVudHMiLCJ3aXRob3V0IiwiZGlmZmVyZW5jZSIsInVuaXEiLCJ1bmlxdWUiLCJpc1NvcnRlZCIsImlzQm9vbGVhbiIsInNlZW4iLCJ1bmlvbiIsImludGVyc2VjdGlvbiIsImFyZ3NMZW5ndGgiLCJ6aXAiLCJ1bnppcCIsImNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyIiwiZmluZExhc3RJbmRleCIsInNvcnRlZEluZGV4IiwibG93IiwiaGlnaCIsIm1pZCIsImZsb29yIiwiY3JlYXRlSW5kZXhGaW5kZXIiLCJwcmVkaWNhdGVGaW5kIiwiaXNOYU4iLCJsYXN0SW5kZXhPZiIsInJhbmdlIiwic3RvcCIsInN0ZXAiLCJjZWlsIiwiZXhlY3V0ZUJvdW5kIiwic291cmNlRnVuYyIsImJvdW5kRnVuYyIsImNhbGxpbmdDb250ZXh0IiwiYm91bmQiLCJib3VuZEFyZ3MiLCJwb3NpdGlvbiIsImJpbmRBbGwiLCJtZW1vaXplIiwiaGFzaGVyIiwiY2FjaGUiLCJhZGRyZXNzIiwiZGVsYXkiLCJ3YWl0Iiwic2V0VGltZW91dCIsImRlZmVyIiwidGhyb3R0bGUiLCJ0aW1lb3V0IiwicHJldmlvdXMiLCJsYXRlciIsImxlYWRpbmciLCJub3ciLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJ0cmFpbGluZyIsImRlYm91bmNlIiwiaW1tZWRpYXRlIiwidGltZXN0YW1wIiwiY2FsbE5vdyIsIndyYXAiLCJ3cmFwcGVyIiwiY29tcG9zZSIsImFmdGVyIiwidGltZXMiLCJiZWZvcmUiLCJvbmNlIiwiaGFzRW51bUJ1ZyIsIm5vbkVudW1lcmFibGVQcm9wcyIsImNvbGxlY3ROb25FbnVtUHJvcHMiLCJub25FbnVtSWR4IiwicHJvdG8iLCJwcm9wIiwiYWxsS2V5cyIsIm1hcE9iamVjdCIsInBhaXJzIiwiaW52ZXJ0IiwiZnVuY3Rpb25zIiwibWV0aG9kcyIsIm5hbWVzIiwiZXh0ZW5kT3duIiwiYXNzaWduIiwicGljayIsIm9pdGVyYXRlZSIsIm9taXQiLCJTdHJpbmciLCJkZWZhdWx0cyIsImNsb25lIiwidGFwIiwiaW50ZXJjZXB0b3IiLCJpc01hdGNoIiwiZXEiLCJhU3RhY2siLCJiU3RhY2siLCJjbGFzc05hbWUiLCJhcmVBcnJheXMiLCJhQ3RvciIsImJDdG9yIiwicG9wIiwiaXNFcXVhbCIsImlzU3RyaW5nIiwiaXNFbGVtZW50Iiwibm9kZVR5cGUiLCJJbnQ4QXJyYXkiLCJpc0Zpbml0ZSIsInBhcnNlRmxvYXQiLCJpc051bWJlciIsImlzTnVsbCIsImlzVW5kZWZpbmVkIiwiY29uc3RhbnQiLCJwcm9wZXJ0eU9mIiwibWF0Y2hlcyIsImFjY3VtIiwiRGF0ZSIsImdldFRpbWUiLCJlc2NhcGVNYXAiLCJ1bmVzY2FwZU1hcCIsImNyZWF0ZUVzY2FwZXIiLCJlc2NhcGVyIiwibWF0Y2giLCJ0ZXN0UmVnZXhwIiwiUmVnRXhwIiwicmVwbGFjZVJlZ2V4cCIsInVuZXNjYXBlIiwiZmFsbGJhY2siLCJpZENvdW50ZXIiLCJ1bmlxdWVJZCIsInByZWZpeCIsInRlbXBsYXRlU2V0dGluZ3MiLCJldmFsdWF0ZSIsImludGVycG9sYXRlIiwibm9NYXRjaCIsImVzY2FwZXMiLCJ0ZXh0Iiwic2V0dGluZ3MiLCJvbGRTZXR0aW5ncyIsIm9mZnNldCIsInZhcmlhYmxlIiwicmVuZGVyIiwiYXJndW1lbnQiLCJjaGFpbiIsIl9jaGFpbiIsIm1peGluIiwidmFsdWVPZiIsInRvSlNPTiIsIl90eXBlb2YiLCJTeW1ib2wiLCJfY3JlYXRlQ2xhc3MiLCJkZXNjcmlwdG9yIiwid3JpdGFibGUiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9pbmRleCIsIl9pbmRleDIiLCJfaW5kZXgzIiwiX2luZGV4NCIsIl91bmRlcnNjb3JlIiwiX3VuZGVyc2NvcmUyIiwiZGVmYXVsdCIsIl9jbGFzc0NhbGxDaGVjayIsImRlZmFsdXRPcHRpb24iLCJ0aXRsZSIsIm1zZyIsImNhbGxiYWNrIiwiYXV0b0hpZGUiLCJodG1sIiwiQUxFUlRfVFlQRSIsImFsZXJ0IiwiY29uZmlybSIsIndhcm5pbmciLCJvcHQiLCJBbGVydCIsImFsZXJ0Qm94Iiwib3B0aW9uIiwic2hvdyIsImFwcGVuZCIsImJpbmRFdmVudCIsImhpZGUiLCJfdGhpcyIsIiRjb250ZW50IiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsIm9uZSIsInVuYmluZCIsInJlbW92ZSIsIm9uIiwiQ3VzdG9tQWxlcnQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxDQUFDLFNBQVNBLGdDQUFULENBQTBDQyxJQUExQyxFQUFnREMsT0FBaEQsRUFBeUQ7QUFDekQsTUFBRyxpQ0FBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQixpQ0FBT0MsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxPQUFPRCxPQUFQLEdBQWlCRCxTQUFqQixDQURELEtBRUssSUFBRyxJQUFILEVBQ0osaUNB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IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKiFcblxuIEBsaWNlbnNlXG4gaGFuZGxlYmFycyB2NC4wLjExXG5cbkNvcHlyaWdodCAoQykgMjAxMS0yMDE3IGJ5IFllaHVkYSBLYXR6XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHRydWUpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJIYW5kbGViYXJzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkhhbmRsZWJhcnNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XG5cblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpWydkZWZhdWx0J107XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2hhbmRsZWJhcnNCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgYmFzZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oYW5kbGViYXJzQmFzZSk7XG5cblx0Ly8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuXHQvLyAoVGhpcyBpcyBkb25lIHRvIGVhc2lseSBzaGFyZSBjb2RlIGJldHdlZW4gY29tbW9uanMgYW5kIGJyb3dzZSBlbnZzKVxuXG5cdHZhciBfaGFuZGxlYmFyc1NhZmVTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXHR2YXIgX2hhbmRsZWJhcnNTYWZlU3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNTYWZlU3RyaW5nKTtcblxuXHR2YXIgX2hhbmRsZWJhcnNFeGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdHZhciBfaGFuZGxlYmFyc0V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzRXhjZXB0aW9uKTtcblxuXHR2YXIgX2hhbmRsZWJhcnNVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0dmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZWJhcnNVdGlscyk7XG5cblx0dmFyIF9oYW5kbGViYXJzUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5cdHZhciBydW50aW1lID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZWJhcnNSdW50aW1lKTtcblxuXHR2YXIgX2hhbmRsZWJhcnNOb0NvbmZsaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cblx0dmFyIF9oYW5kbGViYXJzTm9Db25mbGljdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzTm9Db25mbGljdCk7XG5cblx0Ly8gRm9yIGNvbXBhdGliaWxpdHkgYW5kIHVzYWdlIG91dHNpZGUgb2YgbW9kdWxlIHN5c3RlbXMsIG1ha2UgdGhlIEhhbmRsZWJhcnMgb2JqZWN0IGEgbmFtZXNwYWNlXG5cdGZ1bmN0aW9uIGNyZWF0ZSgpIHtcblx0ICB2YXIgaGIgPSBuZXcgYmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQoKTtcblxuXHQgIFV0aWxzLmV4dGVuZChoYiwgYmFzZSk7XG5cdCAgaGIuU2FmZVN0cmluZyA9IF9oYW5kbGViYXJzU2FmZVN0cmluZzJbJ2RlZmF1bHQnXTtcblx0ICBoYi5FeGNlcHRpb24gPSBfaGFuZGxlYmFyc0V4Y2VwdGlvbjJbJ2RlZmF1bHQnXTtcblx0ICBoYi5VdGlscyA9IFV0aWxzO1xuXHQgIGhiLmVzY2FwZUV4cHJlc3Npb24gPSBVdGlscy5lc2NhcGVFeHByZXNzaW9uO1xuXG5cdCAgaGIuVk0gPSBydW50aW1lO1xuXHQgIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24gKHNwZWMpIHtcblx0ICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIGhiO1xuXHR9XG5cblx0dmFyIGluc3QgPSBjcmVhdGUoKTtcblx0aW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cblx0X2hhbmRsZWJhcnNOb0NvbmZsaWN0MlsnZGVmYXVsdCddKGluc3QpO1xuXG5cdGluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gaW5zdDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKG9iaikge1xuXHQgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcblx0ICAgIHJldHVybiBvYmo7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBuZXdPYmogPSB7fTtcblxuXHQgICAgaWYgKG9iaiAhPSBudWxsKSB7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xuXHQgICAgcmV0dXJuIG5ld09iajtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcblx0ICAgIFwiZGVmYXVsdFwiOiBvYmpcblx0ICB9O1xuXHR9O1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMilbJ2RlZmF1bHQnXTtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtcblxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcblxuXHR2YXIgX2hlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cdHZhciBfZGVjb3JhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG5cdHZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblx0dmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxuXHR2YXIgVkVSU0lPTiA9ICc0LjAuMTEnO1xuXHRleHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xuXHR2YXIgQ09NUElMRVJfUkVWSVNJT04gPSA3O1xuXG5cdGV4cG9ydHMuQ09NUElMRVJfUkVWSVNJT04gPSBDT01QSUxFUl9SRVZJU0lPTjtcblx0dmFyIFJFVklTSU9OX0NIQU5HRVMgPSB7XG5cdCAgMTogJzw9IDEuMC5yYy4yJywgLy8gMS4wLnJjLjIgaXMgYWN0dWFsbHkgcmV2MiBidXQgZG9lc24ndCByZXBvcnQgaXRcblx0ICAyOiAnPT0gMS4wLjAtcmMuMycsXG5cdCAgMzogJz09IDEuMC4wLXJjLjQnLFxuXHQgIDQ6ICc9PSAxLngueCcsXG5cdCAgNTogJz09IDIuMC4wLWFscGhhLngnLFxuXHQgIDY6ICc+PSAyLjAuMC1iZXRhLjEnLFxuXHQgIDc6ICc+PSA0LjAuMCdcblx0fTtcblxuXHRleHBvcnRzLlJFVklTSU9OX0NIQU5HRVMgPSBSRVZJU0lPTl9DSEFOR0VTO1xuXHR2YXIgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5cdGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuXHQgIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG5cdCAgdGhpcy5wYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuXHQgIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cblx0ICBfaGVscGVycy5yZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xuXHQgIF9kZWNvcmF0b3JzLnJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnModGhpcyk7XG5cdH1cblxuXHRIYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuXHQgIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXG5cblx0ICBsb2dnZXI6IF9sb2dnZXIyWydkZWZhdWx0J10sXG5cdCAgbG9nOiBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZyxcblxuXHQgIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbiByZWdpc3RlckhlbHBlcihuYW1lLCBmbikge1xuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG5cdCAgICAgIGlmIChmbikge1xuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTtcblx0ICAgICAgfVxuXHQgICAgICBfdXRpbHMuZXh0ZW5kKHRoaXMuaGVscGVycywgbmFtZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXJIZWxwZXIobmFtZSkge1xuXHQgICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcblx0ICB9LFxuXG5cdCAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbiByZWdpc3RlclBhcnRpYWwobmFtZSwgcGFydGlhbCkge1xuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0F0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIicgKyBuYW1lICsgJ1wiIGFzIHVuZGVmaW5lZCcpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uIHVucmVnaXN0ZXJQYXJ0aWFsKG5hbWUpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuXHQgIH0sXG5cblx0ICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gcmVnaXN0ZXJEZWNvcmF0b3IobmFtZSwgZm4pIHtcblx0ICAgIGlmIChfdXRpbHMudG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuXHQgICAgICBpZiAoZm4pIHtcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7XG5cdCAgICAgIH1cblx0ICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5kZWNvcmF0b3JzW25hbWVdID0gZm47XG5cdCAgICB9XG5cdCAgfSxcblx0ICB1bnJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbiB1bnJlZ2lzdGVyRGVjb3JhdG9yKG5hbWUpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLmRlY29yYXRvcnNbbmFtZV07XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBsb2cgPSBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZztcblxuXHRleHBvcnRzLmxvZyA9IGxvZztcblx0ZXhwb3J0cy5jcmVhdGVGcmFtZSA9IF91dGlscy5jcmVhdGVGcmFtZTtcblx0ZXhwb3J0cy5sb2dnZXIgPSBfbG9nZ2VyMlsnZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5cdGV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5cdGV4cG9ydHMuZXNjYXBlRXhwcmVzc2lvbiA9IGVzY2FwZUV4cHJlc3Npb247XG5cdGV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5cdGV4cG9ydHMuY3JlYXRlRnJhbWUgPSBjcmVhdGVGcmFtZTtcblx0ZXhwb3J0cy5ibG9ja1BhcmFtcyA9IGJsb2NrUGFyYW1zO1xuXHRleHBvcnRzLmFwcGVuZENvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGg7XG5cdHZhciBlc2NhcGUgPSB7XG5cdCAgJyYnOiAnJmFtcDsnLFxuXHQgICc8JzogJyZsdDsnLFxuXHQgICc+JzogJyZndDsnLFxuXHQgICdcIic6ICcmcXVvdDsnLFxuXHQgIFwiJ1wiOiAnJiN4Mjc7Jyxcblx0ICAnYCc6ICcmI3g2MDsnLFxuXHQgICc9JzogJyYjeDNEOydcblx0fTtcblxuXHR2YXIgYmFkQ2hhcnMgPSAvWyY8PlwiJ2A9XS9nLFxuXHQgICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XG5cblx0ZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcblx0ICByZXR1cm4gZXNjYXBlW2Nocl07XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQob2JqIC8qICwgLi4uc291cmNlICovKSB7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbaV0pIHtcblx0ICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcblx0ICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cblx0ZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xuXHQvLyBTb3VyY2VkIGZyb20gbG9kYXNoXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcblx0LyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xuXHR2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXHR9O1xuXHQvLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuXHQgIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdCAgfTtcblx0fVxuXHRleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5cdC8qIGVzbGludC1lbmFibGUgZnVuYy1zdHlsZSAqL1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblx0Ly8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cblxuXHRmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHQgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gaTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIC0xO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcblx0ICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcblx0ICAgIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcblx0ICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuXHQgICAgICByZXR1cm4gc3RyaW5nLnRvSFRNTCgpO1xuXHQgICAgfSBlbHNlIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gJyc7XG5cdCAgICB9IGVsc2UgaWYgKCFzdHJpbmcpIHtcblx0ICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xuXHQgICAgfVxuXG5cdCAgICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcblx0ICAgIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxuXHQgICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG5cdCAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcblx0ICB9XG5cblx0ICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkge1xuXHQgICAgcmV0dXJuIHN0cmluZztcblx0ICB9XG5cdCAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcblx0ICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVGcmFtZShvYmplY3QpIHtcblx0ICB2YXIgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG5cdCAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcblx0ICByZXR1cm4gZnJhbWU7XG5cdH1cblxuXHRmdW5jdGlvbiBibG9ja1BhcmFtcyhwYXJhbXMsIGlkcykge1xuXHQgIHBhcmFtcy5wYXRoID0gaWRzO1xuXHQgIHJldHVybiBwYXJhbXM7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcblx0ICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcblx0fVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpWydkZWZhdWx0J107XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cblx0ZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcblx0ICB2YXIgbG9jID0gbm9kZSAmJiBub2RlLmxvYyxcblx0ICAgICAgbGluZSA9IHVuZGVmaW5lZCxcblx0ICAgICAgY29sdW1uID0gdW5kZWZpbmVkO1xuXHQgIGlmIChsb2MpIHtcblx0ICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcblx0ICAgIGNvbHVtbiA9IGxvYy5zdGFydC5jb2x1bW47XG5cblx0ICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgY29sdW1uO1xuXHQgIH1cblxuXHQgIHZhciB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuXHQgIC8vIFVuZm9ydHVuYXRlbHkgZXJyb3JzIGFyZSBub3QgZW51bWVyYWJsZSBpbiBDaHJvbWUgKGF0IGxlYXN0KSwgc28gYGZvciBwcm9wIGluIHRtcGAgZG9lc24ndCB3b3JrLlxuXHQgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG5cdCAgfVxuXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0ICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcblx0ICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEV4Y2VwdGlvbik7XG5cdCAgfVxuXG5cdCAgdHJ5IHtcblx0ICAgIGlmIChsb2MpIHtcblx0ICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcblxuXHQgICAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSB1bmRlciBzYWZhcmkgd2hlcmUgd2UgY2FuJ3QgZGlyZWN0bHkgc2V0IHRoZSBjb2x1bW4gdmFsdWVcblx0ICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgICAgaWYgKF9PYmplY3QkZGVmaW5lUHJvcGVydHkpIHtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcblx0ICAgICAgICAgIHZhbHVlOiBjb2x1bW4sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGNhdGNoIChub3ApIHtcblx0ICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cblx0ICB9XG5cdH1cblxuXHRFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gRXhjZXB0aW9uO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcblx0ICByZXR1cm4gJC5zZXREZXNjKGl0LCBrZXksIGRlc2MpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgJE9iamVjdCA9IE9iamVjdDtcblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXG5cdCAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcblx0ICBpc0VudW06ICAgICB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcblx0ICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcblx0ICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuXHQgIHNldERlc2NzOiAgICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyxcblx0ICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXG5cdCAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuXHQgIGdldFN5bWJvbHM6ICRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuXHQgIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcblx0fTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKVsnZGVmYXVsdCddO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0SGVscGVycyA9IHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnM7XG5cblx0dmFyIF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cblx0dmFyIF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcpO1xuXG5cdHZhciBfaGVscGVyc0VhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHR2YXIgX2hlbHBlcnNFYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNFYWNoKTtcblxuXHR2YXIgX2hlbHBlcnNIZWxwZXJNaXNzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cblx0dmFyIF9oZWxwZXJzSGVscGVyTWlzc2luZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzSGVscGVyTWlzc2luZyk7XG5cblx0dmFyIF9oZWxwZXJzSWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXHR2YXIgX2hlbHBlcnNJZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzSWYpO1xuXG5cdHZhciBfaGVscGVyc0xvZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5cdHZhciBfaGVscGVyc0xvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzTG9nKTtcblxuXHR2YXIgX2hlbHBlcnNMb29rdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuXHR2YXIgX2hlbHBlcnNMb29rdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc0xvb2t1cCk7XG5cblx0dmFyIF9oZWxwZXJzV2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG5cdHZhciBfaGVscGVyc1dpdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc1dpdGgpO1xuXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcblx0ICBfaGVscGVyc0Jsb2NrSGVscGVyTWlzc2luZzJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XG5cdCAgX2hlbHBlcnNFYWNoMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcblx0ICBfaGVscGVyc0hlbHBlck1pc3NpbmcyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xuXHQgIF9oZWxwZXJzSWYyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xuXHQgIF9oZWxwZXJzTG9nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcblx0ICBfaGVscGVyc0xvb2t1cDJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XG5cdCAgX2hlbHBlcnNXaXRoMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcblx0fVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG5cdCAgICB2YXIgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcblx0ICAgICAgICBmbiA9IG9wdGlvbnMuZm47XG5cblx0ICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG5cdCAgICAgIHJldHVybiBmbih0aGlzKTtcblx0ICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gZmFsc2UgfHwgY29udGV4dCA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuXHQgICAgfSBlbHNlIGlmIChfdXRpbHMuaXNBcnJheShjb250ZXh0KSkge1xuXHQgICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG5cdCAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcblx0ICAgICAgICB2YXIgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuXHQgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBfdXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuXHQgICAgICAgIG9wdGlvbnMgPSB7IGRhdGE6IGRhdGEgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMilbJ2RlZmF1bHQnXTtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdlYWNoJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcblx0ICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTXVzdCBwYXNzIGl0ZXJhdG9yIHRvICNlYWNoJyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBmbiA9IG9wdGlvbnMuZm4sXG5cdCAgICAgICAgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcblx0ICAgICAgICBpID0gMCxcblx0ICAgICAgICByZXQgPSAnJyxcblx0ICAgICAgICBkYXRhID0gdW5kZWZpbmVkLFxuXHQgICAgICAgIGNvbnRleHRQYXRoID0gdW5kZWZpbmVkO1xuXG5cdCAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG5cdCAgICAgIGNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcblx0ICAgICAgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuXHQgICAgICBkYXRhID0gX3V0aWxzLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG5cdCAgICAgIGlmIChkYXRhKSB7XG5cdCAgICAgICAgZGF0YS5rZXkgPSBmaWVsZDtcblx0ICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG5cdCAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuXHQgICAgICAgIGRhdGEubGFzdCA9ICEhbGFzdDtcblxuXHQgICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuXHQgICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtmaWVsZF0sIHtcblx0ICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgIGJsb2NrUGFyYW1zOiBfdXRpbHMuYmxvY2tQYXJhbXMoW2NvbnRleHRbZmllbGRdLCBmaWVsZF0sIFtjb250ZXh0UGF0aCArIGZpZWxkLCBudWxsXSlcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuXHQgICAgICBpZiAoX3V0aWxzLmlzQXJyYXkoY29udGV4dCkpIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihpLCBpLCBpID09PSBjb250ZXh0Lmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgcHJpb3JLZXkgPSB1bmRlZmluZWQ7XG5cblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dCkge1xuXHQgICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3Rcblx0ICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxuXHQgICAgICAgICAgICAvLyBhbiBpdGVybWVkaWF0ZSBrZXlzIGFycmF5LlxuXHQgICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBwcmlvcktleSA9IGtleTtcblx0ICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEsIHRydWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoaSA9PT0gMCkge1xuXHQgICAgICByZXQgPSBpbnZlcnNlKHRoaXMpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmV0O1xuXHQgIH0pO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKVsnZGVmYXVsdCddO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbiAoKSAvKiBbYXJncywgXW9wdGlvbnMgKi97XG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0cnVjdC5cblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTWlzc2luZyBoZWxwZXI6IFwiJyArIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0ubmFtZSArICdcIicpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2lmJywgZnVuY3Rpb24gKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG5cdCAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7XG5cdCAgICAgIGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTtcblx0ICAgIH1cblxuXHQgICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuXHQgICAgLy8gVGhlIGBpbmNsdWRlWmVyb2Agb3B0aW9uIG1heSBiZSBzZXQgdG8gdHJlYXQgdGhlIGNvbmR0aW9uYWwgYXMgcHVyZWx5IG5vdCBlbXB0eSBiYXNlZCBvbiB0aGVcblx0ICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG5cdCAgICBpZiAoIW9wdGlvbnMuaGFzaC5pbmNsdWRlWmVybyAmJiAhY29uZGl0aW9uYWwgfHwgX3V0aWxzLmlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XG5cdCAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd1bmxlc3MnLCBmdW5jdGlvbiAoY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHsgZm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNoIH0pO1xuXHQgIH0pO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uICgpIC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi97XG5cdCAgICB2YXIgYXJncyA9IFt1bmRlZmluZWRdLFxuXHQgICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdCAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbGV2ZWwgPSAxO1xuXHQgICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG5cdCAgICAgIGxldmVsID0gb3B0aW9ucy5oYXNoLmxldmVsO1xuXHQgICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmxldmVsICE9IG51bGwpIHtcblx0ICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG5cdCAgICB9XG5cdCAgICBhcmdzWzBdID0gbGV2ZWw7XG5cblx0ICAgIGluc3RhbmNlLmxvZy5hcHBseShpbnN0YW5jZSwgYXJncyk7XG5cdCAgfSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24gKG9iaiwgZmllbGQpIHtcblx0ICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcblx0ICB9KTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcblx0ICAgIGlmIChfdXRpbHMuaXNGdW5jdGlvbihjb250ZXh0KSkge1xuXHQgICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZm4gPSBvcHRpb25zLmZuO1xuXG5cdCAgICBpZiAoIV91dGlscy5pc0VtcHR5KGNvbnRleHQpKSB7XG5cdCAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXHQgICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG5cdCAgICAgICAgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuXHQgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBfdXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuXHQgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgYmxvY2tQYXJhbXM6IF91dGlscy5ibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpWydkZWZhdWx0J107XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0cy5yZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzID0gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycztcblxuXHR2YXIgX2RlY29yYXRvcnNJbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuXHR2YXIgX2RlY29yYXRvcnNJbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVjb3JhdG9yc0lubGluZSk7XG5cblx0ZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuXHQgIF9kZWNvcmF0b3JzSW5saW5lMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcblx0fVxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uIChmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuXHQgICAgdmFyIHJldCA9IGZuO1xuXHQgICAgaWYgKCFwcm9wcy5wYXJ0aWFscykge1xuXHQgICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xuXHQgICAgICByZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3B0aW9ucykge1xuXHQgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuXHQgICAgICAgIHZhciBvcmlnaW5hbCA9IGNvbnRhaW5lci5wYXJ0aWFscztcblx0ICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBfdXRpbHMuZXh0ZW5kKHt9LCBvcmlnaW5hbCwgcHJvcHMucGFydGlhbHMpO1xuXHQgICAgICAgIHZhciByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcblx0ICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBwcm9wcy5wYXJ0aWFsc1tvcHRpb25zLmFyZ3NbMF1dID0gb3B0aW9ucy5mbjtcblxuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9KTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBsb2dnZXIgPSB7XG5cdCAgbWV0aG9kTWFwOiBbJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddLFxuXHQgIGxldmVsOiAnaW5mbycsXG5cblx0ICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG5cdCAgbG9va3VwTGV2ZWw6IGZ1bmN0aW9uIGxvb2t1cExldmVsKGxldmVsKSB7XG5cdCAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YXIgbGV2ZWxNYXAgPSBfdXRpbHMuaW5kZXhPZihsb2dnZXIubWV0aG9kTWFwLCBsZXZlbC50b0xvd2VyQ2FzZSgpKTtcblx0ICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcblx0ICAgICAgICBsZXZlbCA9IGxldmVsTWFwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbGV2ZWw7XG5cdCAgfSxcblxuXHQgIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG5cdCAgbG9nOiBmdW5jdGlvbiBsb2cobGV2ZWwpIHtcblx0ICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuXHQgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBsb2dnZXIubG9va3VwTGV2ZWwobG9nZ2VyLmxldmVsKSA8PSBsZXZlbCkge1xuXHQgICAgICB2YXIgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG5cdCAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7XG5cdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdCAgICAgICAgbWV0aG9kID0gJ2xvZyc7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZSA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgICBtZXNzYWdlW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbnNvbGVbbWV0aG9kXS5hcHBseShjb25zb2xlLCBtZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGxvZ2dlcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZnVuY3Rpb24gU2FmZVN0cmluZyhzdHJpbmcpIHtcblx0ICB0aGlzLnN0cmluZyA9IHN0cmluZztcblx0fVxuXG5cdFNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gU2FmZVN0cmluZy5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xuXHR9O1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNhZmVTdHJpbmc7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfT2JqZWN0JHNlYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVsnZGVmYXVsdCddO1xuXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcblxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMilbJ2RlZmF1bHQnXTtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzLmNoZWNrUmV2aXNpb24gPSBjaGVja1JldmlzaW9uO1xuXHRleHBvcnRzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cdGV4cG9ydHMud3JhcFByb2dyYW0gPSB3cmFwUHJvZ3JhbTtcblx0ZXhwb3J0cy5yZXNvbHZlUGFydGlhbCA9IHJlc29sdmVQYXJ0aWFsO1xuXHRleHBvcnRzLmludm9rZVBhcnRpYWwgPSBpbnZva2VQYXJ0aWFsO1xuXHRleHBvcnRzLm5vb3AgPSBub29wO1xuXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XG5cblx0dmFyIF9iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHRmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuXHQgIHZhciBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuXHQgICAgICBjdXJyZW50UmV2aXNpb24gPSBfYmFzZS5DT01QSUxFUl9SRVZJU0lPTjtcblxuXHQgIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcblx0ICAgIGlmIChjb21waWxlclJldmlzaW9uIDwgY3VycmVudFJldmlzaW9uKSB7XG5cdCAgICAgIHZhciBydW50aW1lVmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXG5cdCAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gX2Jhc2UuUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGFuIG9sZGVyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgKyAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFVzZSB0aGUgZW1iZWRkZWQgdmVyc2lvbiBpbmZvIHNpbmNlIHRoZSBydW50aW1lIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHJldmlzaW9uIHlldFxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICsgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRlbXBsYXRlKHRlbXBsYXRlU3BlYywgZW52KSB7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICBpZiAoIWVudikge1xuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ05vIGVudmlyb25tZW50IHBhc3NlZCB0byB0ZW1wbGF0ZScpO1xuXHQgIH1cblx0ICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcblx0ICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuXHQgIH1cblxuXHQgIHRlbXBsYXRlU3BlYy5tYWluLmRlY29yYXRvciA9IHRlbXBsYXRlU3BlYy5tYWluX2Q7XG5cblx0ICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuXHQgIC8vIGZvciBleHRlcm5hbCB1c2VycyB0byBvdmVycmlkZSB0aGVzZSBhcyBwc3VlZG8tc3VwcG9ydGVkIEFQSXMuXG5cdCAgZW52LlZNLmNoZWNrUmV2aXNpb24odGVtcGxhdGVTcGVjLmNvbXBpbGVyKTtcblxuXHQgIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zLmhhc2gpIHtcblx0ICAgICAgY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgY29udGV4dCwgb3B0aW9ucy5oYXNoKTtcblx0ICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG5cdCAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblx0ICAgIHZhciByZXN1bHQgPSBlbnYuVk0uaW52b2tlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xuXG5cdCAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcblx0ICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcblx0ICAgICAgcmVzdWx0ID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdKGNvbnRleHQsIG9wdGlvbnMpO1xuXHQgICAgfVxuXHQgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG5cdCAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuXHQgICAgICAgIHZhciBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgICAgIGlmICghbGluZXNbaV0gJiYgaSArIDEgPT09IGwpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGxpbmVzW2ldID0gb3B0aW9ucy5pbmRlbnQgKyBsaW5lc1tpXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gSnVzdCBhZGQgd2F0ZXJcblx0ICB2YXIgY29udGFpbmVyID0ge1xuXHQgICAgc3RyaWN0OiBmdW5jdGlvbiBzdHJpY3Qob2JqLCBuYW1lKSB7XG5cdCAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvYmpbbmFtZV07XG5cdCAgICB9LFxuXHQgICAgbG9va3VwOiBmdW5jdGlvbiBsb29rdXAoZGVwdGhzLCBuYW1lKSB7XG5cdCAgICAgIHZhciBsZW4gPSBkZXB0aHMubGVuZ3RoO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBsYW1iZGE6IGZ1bmN0aW9uIGxhbWJkYShjdXJyZW50LCBjb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG5cdCAgICB9LFxuXG5cdCAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuXHQgICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cblx0ICAgIGZuOiBmdW5jdGlvbiBmbihpKSB7XG5cdCAgICAgIHZhciByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG5cdCAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xuXHQgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfSxcblxuXHQgICAgcHJvZ3JhbXM6IFtdLFxuXHQgICAgcHJvZ3JhbTogZnVuY3Rpb24gcHJvZ3JhbShpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG5cdCAgICAgIHZhciBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXG5cdCAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG5cdCAgICAgIGlmIChkYXRhIHx8IGRlcHRocyB8fCBibG9ja1BhcmFtcyB8fCBkZWNsYXJlZEJsb2NrUGFyYW1zKSB7XG5cdCAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG5cdCAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XG5cdCAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcblx0ICAgIH0sXG5cblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEodmFsdWUsIGRlcHRoKSB7XG5cdCAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH0sXG5cdCAgICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UocGFyYW0sIGNvbW1vbikge1xuXHQgICAgICB2YXIgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG5cdCAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgcGFyYW0gIT09IGNvbW1vbikge1xuXHQgICAgICAgIG9iaiA9IFV0aWxzLmV4dGVuZCh7fSwgY29tbW9uLCBwYXJhbSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gb2JqO1xuXHQgICAgfSxcblx0ICAgIC8vIEFuIGVtcHR5IG9iamVjdCB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIG51bGwtY29udGV4dHNcblx0ICAgIG51bGxDb250ZXh0OiBfT2JqZWN0JHNlYWwoe30pLFxuXG5cdCAgICBub29wOiBlbnYuVk0ubm9vcCxcblx0ICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHJldChjb250ZXh0KSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG5cdCAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuXHQgICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcblx0ICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsICYmIHRlbXBsYXRlU3BlYy51c2VEYXRhKSB7XG5cdCAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcblx0ICAgIH1cblx0ICAgIHZhciBkZXB0aHMgPSB1bmRlZmluZWQsXG5cdCAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcblx0ICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG5cdCAgICAgIGlmIChvcHRpb25zLmRlcHRocykge1xuXHQgICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQgLyosIG9wdGlvbnMqLykge1xuXHQgICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuXHQgICAgfVxuXHQgICAgbWFpbiA9IGV4ZWN1dGVEZWNvcmF0b3JzKHRlbXBsYXRlU3BlYy5tYWluLCBtYWluLCBjb250YWluZXIsIG9wdGlvbnMuZGVwdGhzIHx8IFtdLCBkYXRhLCBibG9ja1BhcmFtcyk7XG5cdCAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcblx0ICB9XG5cdCAgcmV0LmlzVG9wID0gdHJ1ZTtcblxuXHQgIHJldC5fc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcblx0ICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cblx0ICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XG5cdCAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsIHx8IHRlbXBsYXRlU3BlYy51c2VEZWNvcmF0b3JzKSB7XG5cdCAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5kZWNvcmF0b3JzLCBlbnYuZGVjb3JhdG9ycyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuXHQgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuXHQgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IG9wdGlvbnMuZGVjb3JhdG9ycztcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uIChpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG5cdCAgICBpZiAodGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zICYmICFibG9ja1BhcmFtcykge1xuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnbXVzdCBwYXNzIGJsb2NrIHBhcmFtcycpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcblx0ICB9O1xuXHQgIHJldHVybiByZXQ7XG5cdH1cblxuXHRmdW5jdGlvbiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG5cdCAgZnVuY3Rpb24gcHJvZyhjb250ZXh0KSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG5cdCAgICB2YXIgY3VycmVudERlcHRocyA9IGRlcHRocztcblx0ICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPSBkZXB0aHNbMF0gJiYgIShjb250ZXh0ID09PSBjb250YWluZXIubnVsbENvbnRleHQgJiYgZGVwdGhzWzBdID09PSBudWxsKSkge1xuXHQgICAgICBjdXJyZW50RGVwdGhzID0gW2NvbnRleHRdLmNvbmNhdChkZXB0aHMpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZm4oY29udGFpbmVyLCBjb250ZXh0LCBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLCBvcHRpb25zLmRhdGEgfHwgZGF0YSwgYmxvY2tQYXJhbXMgJiYgW29wdGlvbnMuYmxvY2tQYXJhbXNdLmNvbmNhdChibG9ja1BhcmFtcyksIGN1cnJlbnREZXB0aHMpO1xuXHQgIH1cblxuXHQgIHByb2cgPSBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKTtcblxuXHQgIHByb2cucHJvZ3JhbSA9IGk7XG5cdCAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuXHQgIHByb2cuYmxvY2tQYXJhbXMgPSBkZWNsYXJlZEJsb2NrUGFyYW1zIHx8IDA7XG5cdCAgcmV0dXJuIHByb2c7XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG5cdCAgaWYgKCFwYXJ0aWFsKSB7XG5cdCAgICBpZiAob3B0aW9ucy5uYW1lID09PSAnQHBhcnRpYWwtYmxvY2snKSB7XG5cdCAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV07XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcblx0ICAgIC8vIFRoaXMgaXMgYSBkeW5hbWljIHBhcnRpYWwgdGhhdCByZXR1cm5lZCBhIHN0cmluZ1xuXHQgICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcblx0ICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuXHQgIH1cblx0ICByZXR1cm4gcGFydGlhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuXHQgIC8vIFVzZSB0aGUgY3VycmVudCBjbG9zdXJlIGNvbnRleHQgdG8gc2F2ZSB0aGUgcGFydGlhbC1ibG9jayBpZiB0aGlzIHBhcnRpYWxcblx0ICB2YXIgY3VycmVudFBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcblx0ICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuXHQgIGlmIChvcHRpb25zLmlkcykge1xuXHQgICAgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoID0gb3B0aW9ucy5pZHNbMF0gfHwgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoO1xuXHQgIH1cblxuXHQgIHZhciBwYXJ0aWFsQmxvY2sgPSB1bmRlZmluZWQ7XG5cdCAgaWYgKG9wdGlvbnMuZm4gJiYgb3B0aW9ucy5mbiAhPT0gbm9vcCkge1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgb3B0aW9ucy5kYXRhID0gX2Jhc2UuY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcblx0ICAgICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byBnZXQgYWNjZXNzIHRvIGN1cnJlbnRQYXJ0aWFsQmxvY2sgZnJvbSB0aGUgY2xvc3VyZVxuXHQgICAgICB2YXIgZm4gPSBvcHRpb25zLmZuO1xuXHQgICAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGZ1bmN0aW9uIHBhcnRpYWxCbG9ja1dyYXBwZXIoY29udGV4dCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cblx0ICAgICAgICAvLyBSZXN0b3JlIHRoZSBwYXJ0aWFsLWJsb2NrIGZyb20gdGhlIGNsb3N1cmUgZm9yIHRoZSBleGVjdXRpb24gb2YgdGhlIGJsb2NrXG5cdCAgICAgICAgLy8gaS5lLiB0aGUgcGFydCBpbnNpZGUgdGhlIGJsb2NrIG9mIHRoZSBwYXJ0aWFsIGNhbGwuXG5cdCAgICAgICAgb3B0aW9ucy5kYXRhID0gX2Jhc2UuY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcblx0ICAgICAgICBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGN1cnJlbnRQYXJ0aWFsQmxvY2s7XG5cdCAgICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuXHQgICAgICB9O1xuXHQgICAgICBpZiAoZm4ucGFydGlhbHMpIHtcblx0ICAgICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBmbi5wYXJ0aWFscyk7XG5cdCAgICAgIH1cblx0ICAgIH0pKCk7XG5cdCAgfVxuXG5cdCAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcblx0ICAgIHBhcnRpYWwgPSBwYXJ0aWFsQmxvY2s7XG5cdCAgfVxuXG5cdCAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuXHQgIH0gZWxzZSBpZiAocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdCAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBub29wKCkge1xuXHQgIHJldHVybiAnJztcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcblx0ICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcblx0ICAgIGRhdGEgPSBkYXRhID8gX2Jhc2UuY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcblx0ICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG5cdCAgfVxuXHQgIHJldHVybiBkYXRhO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xuXHQgIGlmIChmbi5kZWNvcmF0b3IpIHtcblx0ICAgIHZhciBwcm9wcyA9IHt9O1xuXHQgICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcblx0ICAgIFV0aWxzLmV4dGVuZChwcm9nLCBwcm9wcyk7XG5cdCAgfVxuXHQgIHJldHVybiBwcm9nO1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMjMpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KS5PYmplY3Quc2VhbDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxuXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSgnc2VhbCcsIGZ1bmN0aW9uKCRzZWFsKXtcblx0ICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG5cdCAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwoaXQpIDogaXQ7XG5cdCAgfTtcblx0fSk7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG5cdHZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNylcblx0ICAsIGNvcmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxuXHQgICwgZmFpbHMgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG5cdCAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuXHQgICAgLCBleHAgPSB7fTtcblx0ICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuXHQgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBnbG9iYWwgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgY29yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcblx0ICAsIGN0eCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXG5cdCAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuXHR2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG5cdCAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcblx0ICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuXHQgICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG5cdCAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcblx0ICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuXHQgICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG5cdCAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG5cdCAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cblx0ICAgICwga2V5LCBvd24sIG91dDtcblx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcblx0ICBmb3Ioa2V5IGluIHNvdXJjZSl7XG5cdCAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcblx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XG5cdCAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG5cdCAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcblx0ICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuXHQgICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cblx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG5cdCAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuXHQgICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcblx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG5cdCAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xuXHQgICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xuXHQgICAgICB9O1xuXHQgICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG5cdCAgICAgIHJldHVybiBGO1xuXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG5cdCAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG5cdCAgICBpZihJU19QUk9UTykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XG5cdCAgfVxuXHR9O1xuXHQvLyB0eXBlIGJpdG1hcFxuXHQkZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXG5cdCRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcblx0JGV4cG9ydC5TID0gNDsgIC8vIHN0YXRpY1xuXHQkZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cblx0JGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcblx0JGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcblx0bW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcblx0dmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG5cdCAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHRpZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMS4yLjYnfTtcblx0aWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblx0dmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuXHQgIGFGdW5jdGlvbihmbik7XG5cdCAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcblx0ICBzd2l0Y2gobGVuZ3RoKXtcblx0ICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcblx0ICAgIH07XG5cdCAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuXHQgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuICEhZXhlYygpO1xuXHQgIH0gY2F0Y2goZSl7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoSGFuZGxlYmFycykge1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcblx0ICAgICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICBIYW5kbGViYXJzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAocm9vdC5IYW5kbGViYXJzID09PSBIYW5kbGViYXJzKSB7XG5cdCAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEhhbmRsZWJhcnM7XG5cdCAgfTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG4vKioqLyB9KSxcbi8qIDEgKi8sXG4vKiAyICovLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJjdXN0b20tYWxlcnRcIjpcImN1c3RvbS1hbGVydFwiLFwiY3VzdG9tLWFsZXJ0LWNvbnRlbnRcIjpcImN1c3RvbS1hbGVydC1jb250ZW50XCIsXCJjdXN0b20tYWxlcnQtdGl0bGVcIjpcImN1c3RvbS1hbGVydC10aXRsZVwiLFwidGl0bGUtb25saW5lXCI6XCJ0aXRsZS1vbmxpbmVcIixcImN1c3RvbS10aXAtc2luZ2xlXCI6XCJjdXN0b20tdGlwLXNpbmdsZVwiLFwiY3VzdG9tLWFsZXJ0LW1zZ1wiOlwiY3VzdG9tLWFsZXJ0LW1zZ1wiLFwidGl0bGUtcGFkZGluZy10d29cIjpcInRpdGxlLXBhZGRpbmctdHdvXCIsXCJjdXN0b20tYWxlcnQtYnRuLWdyb3VwXCI6XCJjdXN0b20tYWxlcnQtYnRuLWdyb3VwXCIsXCJjdXN0b20tYWxlcnQtYnRuXCI6XCJjdXN0b20tYWxlcnQtYnRuXCIsXCJjdXN0b20tdHlwZS1hbGVydFwiOlwiY3VzdG9tLXR5cGUtYWxlcnRcIixcImN1c3RvbS1hbGVydC1va1wiOlwiY3VzdG9tLWFsZXJ0LW9rXCIsXCJjdXN0b20tdHlwZS13YXJuaW5nXCI6XCJjdXN0b20tdHlwZS13YXJuaW5nXCIsXCJjdXN0b20tYWxlcnQtY2FuY2VsXCI6XCJjdXN0b20tYWxlcnQtY2FuY2VsXCIsXCJjdXN0b20tYWxlcnQtbWFza1wiOlwiY3VzdG9tLWFsZXJ0LW1hc2tcIixcImluXCI6XCJpblwiLFwiYm91bmNlSW5cIjpcImJvdW5jZUluXCIsXCJvdXRcIjpcIm91dFwiLFwiYm91bmNlT3V0XCI6XCJib3VuY2VPdXRcIixcImZuLWhpZGVcIjpcImZuLWhpZGVcIn07XG5cbi8qKiovIH0pLFxuLyogNCAqLyxcbi8qIDUgKi8sXG4vKiA2ICovLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgSGFuZGxlYmFycyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5mdW5jdGlvbiBfX2RlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgKG9iai5fX2VzTW9kdWxlID8gb2JqW1wiZGVmYXVsdFwiXSA6IG9iaik7IH1cbm1vZHVsZS5leHBvcnRzID0gKEhhbmRsZWJhcnNbXCJkZWZhdWx0XCJdIHx8IEhhbmRsZWJhcnMpLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJjdXN0b20tYWxlcnQtdGl0bGVcXFwiPlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbihjb250YWluZXIubGFtYmRhKGRlcHRoMCwgZGVwdGgwKSlcbiAgICArIFwiPC9wPlxcblwiO1xufSxcIjNcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSxibG9ja1BhcmFtcyxkZXB0aHMpIHtcbiAgICB2YXIgYWxpYXMxPWNvbnRhaW5lci5sYW1iZGEsIGFsaWFzMj1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcImN1c3RvbS1hbGVydC1tc2cgXCJcbiAgICArIGFsaWFzMihhbGlhczEoKGRlcHRoc1sxXSAhPSBudWxsID8gZGVwdGhzWzFdLmlzSGlkZSA6IGRlcHRoc1sxXSksIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArIGFsaWFzMihhbGlhczEoZGVwdGgwLCBkZXB0aDApKVxuICAgICsgXCI8L3A+XFxuXCI7XG59LFwiNVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyO1xuXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImN1c3RvbS1hbGVydC1odG1sXFxcIj5cXG4gICAgICAgICAgICAgICAgXCJcbiAgICArICgoc3RhY2sxID0gKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hcHBlbmRIdG1sIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hcHBlbmRIdG1sIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlcnMuaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSkse1wibmFtZVwiOlwiYXBwZW5kSHRtbFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxuICAgICAgICAgICAgPC9kaXY+XFxuXCI7XG59LFwiN1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlcjtcblxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIiBjbGFzcz1cXFwiY3VzdG9tLWFsZXJ0LWJ0biBjdXN0b20tYWxlcnQtY2FuY2VsXFxcIj5cIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jYW5jZWxUZXh0IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jYW5jZWxUZXh0IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlcnMuaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSkse1wibmFtZVwiOlwiY2FuY2VsVGV4dFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2E+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhLGJsb2NrUGFyYW1zLGRlcHRocykge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8ZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjdXN0b20tYWxlcnQgaW4gY3VzdG9tLXR5cGUtXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnR5cGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnR5cGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInR5cGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImN1c3RvbS1hbGVydC1jb250ZW50IFwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZUNsYXNzTmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGVDbGFzc05hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInRpdGxlQ2xhc3NOYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIiBcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuY29udGVudENsYXNzTmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29udGVudENsYXNzTmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiY29udGVudENsYXNzTmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGVBTEwgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArICgoc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXBzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDMsIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYXBwZW5kSHRtbCA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImN1c3RvbS1hbGVydC1idG4tZ3JvdXBcXFwiPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2hvd0NhbmNlbCA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICAgICAgPGEgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIiBjbGFzcz1cXFwiY3VzdG9tLWFsZXJ0LWJ0biBjdXN0b20tYWxlcnQtb2tcXFwiPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5va1RleHQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm9rVGV4dCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwib2tUZXh0XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY3VzdG9tLWFsZXJ0LW1hc2tcXFwiPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZSxcInVzZURlcHRoc1wiOnRydWV9KTtcblxuLyoqKi8gfSksXG4vKiA4ICovLFxuLyogOSAqLyxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfaW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX2luZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZGV4KTtcblxudmFyIF9pbmRleDMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2luZGV4NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZGV4Myk7XG5cbnZhciBfdW5kZXJzY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX3VuZGVyc2NvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdW5kZXJzY29yZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICog5by55qGG77yM6buY6K6kYWxlcnTnsbvlnotcbiAqL1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGRlZmFsdXRPcHRpb24gPSB7XG4gICAgdGl0bGU6IFwi5rip6aao5o+Q56S6XCIsXG4gICAgbXNnOiBcIlwiLFxuICAgIG9rVGV4dDogXCLnoa7lrppcIixcbiAgICBjYW5jZWxUZXh0OiBcIuWPlua2iFwiLFxuICAgIGNhbGxiYWNrOiBub29wLFxuICAgIGF1dG9IaWRlOiB0cnVlLFxuICAgIHR5cGU6IFwiYWxlcnRcIixcbiAgICBodG1sOiAnJ1xufTtcblxudmFyIEFMRVJUX1RZUEUgPSB7XG4gICAgYWxlcnQ6IFwiYWxlcnRcIixcbiAgICBjb25maXJtOiBcImNvbmZpcm1cIixcbiAgICB3YXJuaW5nOiAnd2FybmluZydcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKG9wdCwgZGVmYXVsdHMpIHtcbiAgICBpZiAob3B0Lmh0bWwpIHtcbiAgICAgICAgb3B0Lm1zZyA9ICcnO1xuICAgIH1cbiAgICBpZiAob3B0LnR5cGUgPT0gJ3dhcm5pbmcnICYmIG9wdC50aXRsZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0LnRpdGxlID0gJyc7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICBpZiAob3B0W2tleV0gPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdDtcbn1cblxudmFyIEFsZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsZXJ0KG9wdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxlcnQpO1xuXG4gICAgICAgIHRoaXMuYWxlcnRCb3ggPSBudWxsO1xuICAgICAgICB0aGlzLm9wdGlvbiA9IGRlZmF1bHRzKG9wdCwgZGVmYWx1dE9wdGlvbik7XG4gICAgICAgIHRoaXMub3B0aW9uLnNob3dDYW5jZWwgPSB0aGlzLm9wdGlvbi50eXBlID09IEFMRVJUX1RZUEUuY29uZmlybTtcblxuICAgICAgICB0aGlzLm9wdGlvbi50aXRsZUFMTCA9IF91bmRlcnNjb3JlMi5kZWZhdWx0LmlzQXJyYXkodGhpcy5vcHRpb24udGl0bGUpID8gdGhpcy5vcHRpb24udGl0bGUgOiBbdGhpcy5vcHRpb24udGl0bGVdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24uaHRtbCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLmFwcGVuZEh0bWwgPSB0aGlzLm9wdGlvbi5odG1sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24uYXBwZW5kSHRtbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb24udGlwcyA9IF91bmRlcnNjb3JlMi5kZWZhdWx0LmlzQXJyYXkodGhpcy5vcHRpb24ubXNnKSA/IHRoaXMub3B0aW9uLm1zZyA6IFt0aGlzLm9wdGlvbi5tc2ddO1xuICAgICAgICB0aGlzLm9wdGlvbi5jb250ZW50Q2xhc3NOYW1lID0gdGhpcy5vcHRpb24udGlwcy5sZW5ndGggPD0gMSA/IFwiY3VzdG9tLXRpcC1zaW5nbGVcIiA6IFwiXCI7XG4gICAgICAgIHRoaXMub3B0aW9uLmlzSGlkZSA9IHRoaXMub3B0aW9uLm1zZyA9PT0gJycgPyBcImZuLWhpZGVcIiA6ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi50aXRsZUFMTC5sZW5ndGggPT09IDEgJiYgdGhpcy5vcHRpb24ubXNnID09PSAnJyAmJiB0aGlzLm9wdGlvbi5odG1sID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24udGl0bGVDbGFzc05hbWUgPSBcInRpdGxlLW9ubGluZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uLnRpdGxlQUxMLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnRpdGxlQ2xhc3NOYW1lID0gXCJ0aXRsZS1wYWRkaW5nLXR3b1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaG93KHRoaXMub3B0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmmL7npLpcbiAgICAgKiBAcGFyYW0gb3B0XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBbGVydCwgW3tcbiAgICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KG9wdCkge1xuICAgICAgICAgICAgdGhpcy5hbGVydEJveCA9ICQoKDAsIF9pbmRleDIuZGVmYXVsdCkob3B0KSk7XG4gICAgICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5hbGVydEJveCk7XG4gICAgICAgICAgICB0aGlzLmJpbmRFdmVudChvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmakOiXj1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyICRjb250ZW50ID0gdGhpcy5hbGVydEJveC5maW5kKCcuY3VzdG9tLWFsZXJ0Jyk7XG4gICAgICAgICAgICAkY29udGVudC5yZW1vdmVDbGFzcygnaW4nKS5hZGRDbGFzcygnb3V0Jyk7XG4gICAgICAgICAgICAkY29udGVudC5vbmUoJ3RyYW5zaXRpb25lbmQgd2Via2l0VHJhbnNpdGlvbkVuZCBhbmltYXRpb25lbmQgd2Via2l0QW5pbWF0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRjb250ZW50LnJlbW92ZUNsYXNzKCdvdXQnKTtcbiAgICAgICAgICAgICAgICAkY29udGVudC51bmJpbmQoJ3RyYW5zaXRpb25lbmQnKS51bmJpbmQoJ3dlYmtpdFRyYW5zaXRpb25FbmQnKS51bmJpbmQoJ2FuaW1hdGlvbmVuZCcpLnVuYmluZCgnd2Via2l0QW5pbWF0aW9uZW5kJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWxlcnRCb3gucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmluZEV2ZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmFsZXJ0Qm94LmZpbmQoXCIuY3VzdG9tLWFsZXJ0LW9rXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbi5hdXRvSGlkZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb24udHlwZSA9PT0gQUxFUlRfVFlQRS5jb25maXJtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGVydEJveC5maW5kKFwiLmN1c3RvbS1hbGVydC1jYW5jZWxcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbi5hdXRvSGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWxlcnQ7XG59KCk7XG5cbmZ1bmN0aW9uIEN1c3RvbUFsZXJ0KCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG9wdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbiA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciB0eXBlID0gb3B0aW9uc1sxXSA9PT0gJ2NvbmZpcm0nID8gJ2NvbmZpcm0nIDogJ2FsZXJ0JztcbiAgICAgICAgb3B0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRpdGxlOiBvcHRpb25zWzBdLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXHU0RjYwXFx1NzBCOVxcdTUxRkJcXHU0RTg2JyArIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnNbMF0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQWxlcnQob3B0aW9uKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ3VzdG9tQWxlcnQ7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvenpjMjAxNjExMDEvRGVza3RvcC9naXQvcGVyc29uYWwvdWktY29tcG9uZW50cy9kaXN0L2FsZXJ0L2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzPzE3YTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9hbGVydF9kZW1vL3Jlc2V0LnNjc3M/NTIyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhZ2VzL2FsZXJ0X2RlbW8vcmVzZXQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ })
/******/ ]);